<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>owlsh ‚Äî Sight Words Terminal</title>
  <meta name="theme-color" content="#0d1117">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
  <link rel="apple-touch-icon" href="icon-192.png">
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            t: {
              bg: '#0d1117',
              surface: '#161b22',
              fg: '#e6edf3',
              dim: '#484f58',
              border: '#30363d',
              accent: '#f4845f',
              blue: '#58a6ff',
              green: '#3fb950',
              red: '#f85149',
              yellow: '#d29922',
              purple: '#bc8cff',
            }
          },
          fontFamily: {
            mono: ['"JetBrains Mono"', '"SF Mono"', '"Cascadia Code"', '"Fira Code"', 'Consolas', 'monospace'],
          }
        }
      },
      safelist: [
        'text-t-accent','text-t-blue','text-t-green','text-t-red',
        'text-t-yellow','text-t-purple','text-t-dim','text-t-fg',
        'font-bold','animate-pulse','underline','opacity-50',
        'bg-t-green/20','bg-t-red/20','md:p-6',
      ]
    }
  </script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
    body { font-family: 'JetBrains Mono', monospace; }
    .scanlines {
      background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px);
      z-index: 10;
    }
    @keyframes blink { 50% { opacity: 0; } }
    .cursor-blink { animation: blink 1s step-end infinite; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(4px); } to { opacity: 1; transform: translateY(0); } }
    .fade-in { animation: fadeIn 0.2s ease-out; }
    @keyframes splashPulse { 0%,100% { opacity:0.3; width:40px; } 50% { opacity:1; width:80px; } }
    #splash {
      position: fixed; inset: 0; z-index: 9999; background: #0d1117;
      display: flex; align-items: center; justify-content: center;
      font-family: 'JetBrains Mono', monospace; transition: opacity 0.4s ease-out;
    }
    #splash.fade-out { opacity: 0; pointer-events: none; }
    #splash pre { margin: 0; }
    #splash .loader { display: inline-block; width: 40px; height: 3px; background: #f4845f; border-radius: 2px; animation: splashPulse 1.5s ease-in-out infinite; }
    @keyframes shake { 0%,100% { transform: translateX(0); } 25% { transform: translateX(-4px); } 75% { transform: translateX(4px); } }
    .shake { animation: shake 0.3s ease-out; }
    @keyframes cardShake { 0%,100% { transform: translateX(0); } 25% { transform: translateX(-6px); } 75% { transform: translateX(6px); } }
    .card-shake { animation: cardShake 0.4s ease-out; }
    @keyframes popIn { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
    .pop-in { animation: popIn 0.25s ease-out; }
    @keyframes cardPop { 0% { transform: scale(0.9); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
    pre { tab-size: 2; }
    #input:focus { outline: none; }
    ::selection { background: rgba(244,132,95,0.3); }
    .logo-wrap { display: block; transform-origin: center top; }
    #back-btn { display: none; cursor: pointer; -webkit-tap-highlight-color: transparent; align-items: center; gap: 2px; padding: 4px 6px; border-radius: 4px; }
    #back-btn:active { background: rgba(255,255,255,0.05); }
    #back-btn.visible { display: inline-flex; }
    #tap-area { padding: 1rem 1rem 0.75rem; border-top: 1px solid #30363d; margin-top: auto; overflow-y: auto; }
    #tap-area.hidden { display: none; }
    html, body { overflow: hidden; height: 100%; background-color: #0d1117; color: #e6edf3; }
    .tap-btn {
      display: inline-flex; align-items: center; justify-content: center;
      min-height: 48px; min-width: 48px; padding: 10px 20px;
      background: rgba(22,27,34,0.6); border: 2px solid #30363d; border-radius: 8px;
      color: #e6edf3; font-family: 'JetBrains Mono', monospace; font-size: 16px;
      cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent;
      transition: border-color 0.15s, transform 0.1s, background 0.15s;
    }
    .tap-btn:active, .tap-btn.pressing { border-color: #f4845f; transform: scale(0.96); }
    .tap-btn-large {
      display: flex; align-items: center; justify-content: center;
      min-height: 56px; width: 100%; padding: 14px 24px;
      background: rgba(22,27,34,0.6); border: 2px solid #f4845f; border-radius: 10px;
      color: #f4845f; font-family: 'JetBrains Mono', monospace; font-size: 20px; font-weight: 700;
      cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent;
      transition: border-color 0.15s, transform 0.1s, background 0.15s;
    }
    .tap-btn-large:active, .tap-btn-large.pressing { background: rgba(244,132,95,0.15); transform: scale(0.97); }
    .word-card {
      display: flex; align-items: center; justify-content: center;
      min-height: 56px; padding: 12px 16px;
      background: rgba(22,27,34,0.6); border: 2px solid #30363d; border-radius: 10px;
      color: #e6edf3; font-family: 'JetBrains Mono', monospace; font-size: 22px; font-weight: 700;
      cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent;
      transition: border-color 0.15s, transform 0.1s, background 0.2s;
      text-transform: uppercase;
    }
    .word-card:active, .word-card.pressing { border-color: #f4845f; transform: scale(0.96); }
    .word-card.correct { border-color: #3fb950; background: rgba(63,185,80,0.15); }
    .word-card.wrong { border-color: #f85149; background: rgba(248,81,73,0.15); }
    .letter-tile {
      display: inline-flex; align-items: center; justify-content: center;
      width: 48px; height: 48px;
      background: rgba(22,27,34,0.6); border: 2px solid #30363d; border-radius: 8px;
      color: #e6edf3; font-family: 'JetBrains Mono', monospace; font-size: 22px; font-weight: 700;
      cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent;
      transition: border-color 0.15s, transform 0.1s, background 0.15s;
      text-transform: uppercase;
    }
    .letter-tile:active, .letter-tile.pressing { border-color: #f4845f; transform: scale(0.93); }
    .letter-tile.used { opacity: 0.3; pointer-events: none; }
    .letter-slot {
      display: inline-flex; align-items: center; justify-content: center;
      width: 48px; height: 48px;
      background: transparent; border: 2px dashed #484f58; border-radius: 8px;
      color: #e6edf3; font-family: 'JetBrains Mono', monospace; font-size: 22px; font-weight: 700;
      user-select: none;
    }
    .letter-slot.filled { border-style: solid; border-color: #58a6ff; background: rgba(88,166,255,0.1); }
    .letter-slot.given { border-style: solid; border-color: #484f58; color: #484f58; }
    .profile-card {
      display: flex; align-items: center; gap: 12px;
      min-height: 56px; width: 100%; padding: 12px 16px;
      background: rgba(22,27,34,0.6); border: 2px solid #30363d; border-radius: 10px;
      color: #e6edf3; font-family: 'JetBrains Mono', monospace; font-size: 16px;
      cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent;
      transition: border-color 0.15s, transform 0.1s, background 0.15s;
    }
    .profile-card:active, .profile-card.pressing { border-color: #f4845f; transform: scale(0.98); }
    .profile-card .avatar { font-size: 20px; }
    .profile-card .name { font-weight: 700; }
    .profile-card .level { color: #484f58; font-size: 13px; }
    .menu-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
    }
    .menu-card {
      display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;
      min-height: 72px; padding: 14px 8px;
      background: rgba(22,27,34,0.6); border: 2px solid #30363d; border-radius: 10px;
      color: #e6edf3; font-family: 'JetBrains Mono', monospace; font-size: 15px;
      cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent;
      transition: border-color 0.15s, transform 0.1s, background 0.15s;
    }
    .menu-card:active, .menu-card.pressing { border-color: #f4845f; transform: scale(0.96); }
    .menu-card .icon { font-size: 24px; }
    /* Responsive: small phones (‚â§380px) */
    @media (max-width: 380px) {
      .tap-btn { font-size: 14px; padding: 8px 14px; min-height: 44px; }
      .tap-btn-large { font-size: 17px; min-height: 48px; padding: 12px 16px; }
      .word-card { font-size: 18px; min-height: 48px; padding: 10px 12px; }
      .letter-tile, .letter-slot { width: 40px; height: 40px; font-size: 18px; }
      .menu-card { min-height: 60px; font-size: 13px; padding: 10px 6px; }
      .profile-card { min-height: 48px; padding: 10px 12px; font-size: 14px; }
      .profile-card .avatar { font-size: 16px; }
      #tap-area { padding: 0.5rem 0.75rem 0.5rem; }
    }
    /* Responsive: tablets and up (‚â•768px) */
    @media (min-width: 768px) {
      .tap-btn { font-size: 17px; padding: 12px 24px; }
      .tap-btn-large { font-size: 22px; min-height: 60px; padding: 16px 28px; }
      .word-card { font-size: 24px; min-height: 64px; }
      .letter-tile, .letter-slot { width: 52px; height: 52px; font-size: 24px; }
      .menu-card { min-height: 80px; font-size: 16px; }
      .menu-grid { gap: 14px; }
      .profile-card { min-height: 64px; padding: 14px 20px; font-size: 17px; }
      .profile-card .avatar { font-size: 24px; }
      .profile-card .level { font-size: 14px; }
      #tap-area { padding: 1.25rem 1.5rem 1rem; }
    }
    /* Responsive: landscape / short viewports */
    @media (max-height: 500px) {
      .tap-btn-large { min-height: 44px; padding: 10px 16px; font-size: 17px; }
      .word-card { min-height: 44px; font-size: 18px; padding: 8px 12px; }
      .menu-card { min-height: 56px; padding: 10px 6px; }
      .profile-card { min-height: 44px; padding: 8px 12px; }
      .letter-tile, .letter-slot { width: 40px; height: 40px; font-size: 18px; }
      #tap-area { padding: 0.5rem 0.75rem; }
    }
    /* Safe area insets for modern phones (notch, home indicator) */
    @supports (padding: env(safe-area-inset-bottom)) {
      body { padding-left: env(safe-area-inset-left); padding-right: env(safe-area-inset-right); }
      #tap-area { padding-bottom: max(0.75rem, env(safe-area-inset-bottom)); }
      #input-bar { padding-bottom: max(0.75rem, env(safe-area-inset-bottom)); }
    }
    #settings-wrap { position: relative; }
    #settings-btn { cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent; padding: 2px; display: flex; align-items: center; opacity: 0.7; }
    #settings-btn:hover { opacity: 1; }
    #settings-panel {
      display: none; position: absolute; top: 100%; right: 0; margin-top: 6px;
      width: 220px; background: #161b22; border: 1px solid #30363d; border-radius: 8px;
      padding: 6px 0; z-index: 50; font-family: 'JetBrains Mono', monospace;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }
    #settings-panel.open { display: block; }
    .settings-row {
      display: flex; align-items: center; justify-content: space-between;
      padding: 8px 14px; font-size: 13px; color: #e6edf3; cursor: pointer;
      user-select: none; -webkit-tap-highlight-color: transparent;
    }
    .settings-row:active { background: rgba(244,132,95,0.08); }
    .settings-row.disabled { opacity: 0.3; pointer-events: none; }
    .settings-divider { height: 1px; background: #21262d; margin: 4px 0; }
    .settings-label { font-size: 11px; color: #484f58; padding: 6px 14px 2px; text-transform: uppercase; letter-spacing: 0.05em; }
    .settings-val { color: #484f58; font-size: 12px; }
  </style>
</head>
<body class="bg-t-bg h-[100dvh] flex flex-col items-center p-3 sm:p-4 md:p-6 selection:bg-t-accent/30 overflow-hidden">
  <!-- Splash screen ‚Äî renders instantly, no Tailwind dependency -->
  <div id="splash">
    <div style="text-align:center;width:100%;max-width:600px;padding:20px">
      <pre style="font-size:11px;line-height:1.3;letter-spacing:0.5px"><span style="color:#3fb950">         .        .    *       .        .
    *       .        .        .     *        .
       .        *        .        .        .
</span><span style="color:#2ea043">          ‚ï±‚ï≤          ‚ï±‚ï≤‚ï±‚ï≤          ‚ï±‚ï≤
         ‚ï±‚ï±‚ï≤‚ï≤        ‚ï±‚ï±  ‚ï≤‚ï≤        ‚ï±‚ï±‚ï≤‚ï≤
        ‚ï±‚ï±  ‚ï≤‚ï≤      ‚ï±‚ï±‚ï±‚ï≤‚ï±‚ï≤‚ï≤‚ï≤      ‚ï±‚ï±  ‚ï≤‚ï≤
       ‚ï±‚ï±‚ï±‚ï≤‚ï±‚ï≤‚ï≤‚ï≤    ‚ï±‚ï±‚ï±    ‚ï≤‚ï≤‚ï≤    ‚ï±‚ï±‚ï±‚ï≤‚ï±‚ï≤‚ï≤‚ï≤
      ‚ï±‚ï±‚ï±    ‚ï≤‚ï≤‚ï≤  ‚ï±‚ï±‚ï±‚ï±‚ï≤  ‚ï±‚ï≤‚ï≤‚ï≤‚ï≤  ‚ï±‚ï±‚ï±    ‚ï≤‚ï≤‚ï≤
     ‚ï±‚ï±‚ï±‚ï±‚ï≤  ‚ï±‚ï≤‚ï≤‚ï≤‚ï≤‚ï±‚ï±‚ï±    ‚ï≤‚ï≤  ‚ï≤‚ï≤‚ï≤‚ï±‚ï±‚ï±‚ï±‚ï≤  ‚ï±‚ï≤‚ï≤‚ï≤‚ï≤
    ‚ï±‚ï±‚ï±‚ï±   ‚ï≤‚ï≤‚ï≤‚ï≤‚ï±‚ï±‚ï±‚ï±‚ï±‚ï≤  ‚ï±‚ï≤‚ï≤‚ï≤‚ï≤‚ï≤‚ï±‚ï±‚ï±‚ï±   ‚ï≤‚ï≤‚ï≤‚ï≤‚ï≤‚ï≤
</span><span style="color:#1a7f37">   ‚ï±‚ï±‚ï±‚ï±‚ï±‚ï≤  ‚ï±‚ï≤‚ï≤‚ï≤‚ï±‚ï±‚ï±‚ï±    ‚ï≤‚ï≤  ‚ï≤‚ï≤‚ï≤‚ï±‚ï±‚ï±‚ï±‚ï±‚ï≤  ‚ï±‚ï≤‚ï≤‚ï≤‚ï≤‚ï≤
  ‚ï±‚ï±‚ï±‚ï±‚ï±   ‚ï≤‚ï≤‚ï≤‚ï≤‚ï±‚ï±‚ï±‚ï±‚ï±‚ï≤  ‚ï±‚ï≤‚ï≤‚ï≤‚ï≤‚ï≤‚ï±‚ï±‚ï±‚ï±‚ï±   ‚ï≤‚ï≤‚ï≤‚ï≤‚ï≤‚ï≤‚ï≤
</span><span style="color:#484f58">        ‚ïë‚ïë          ‚ïë‚ïë‚ïë‚ïë          ‚ïë‚ïë
        ‚ïë‚ïë          ‚ïë‚ïë‚ïë‚ïë          ‚ïë‚ïë
</span><span style="color:#30363d">  ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ïë‚ïë‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ïë‚ïë‚ïë‚ïë‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ïë‚ïë‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì
  ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì</span></pre>
      <div style="margin:30px 0 10px">
        <pre style="font-size:10px;line-height:1.15;color:#f4845f;display:inline-block;text-align:left"> ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë
‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
 ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù</pre>
      </div>
      <pre style="font-size:14px;line-height:1.4;color:#e6edf3">    ‚ñÑ‚ñà‚ñà‚ñà‚ñÑ
   ‚ñà ‚óâ ‚óâ ‚ñà
    ‚ñà ‚ñæ ‚ñà
    ‚ñÄ‚ñà‚ñà‚ñà‚ñÄ
     ‚ñà ‚ñà
    ‚ñÄ   ‚ñÄ</pre>
      <div style="color:#484f58;font-size:12px;margin-top:8px;letter-spacing:0.1em">sight words terminal</div>
      <div style="margin-top:20px"><div class="loader"></div></div>
    </div>
  </div>

  <div class="w-full max-w-[68ch] flex flex-col h-full">
    <!-- Terminal title bar -->
    <div class="flex items-center gap-2 px-4 py-2 bg-t-surface rounded-t-lg border border-t-border shrink-0">
      <div class="flex gap-1.5">
        <div class="w-2.5 h-2.5 rounded-full bg-t-red/80"></div>
        <div class="w-2.5 h-2.5 rounded-full bg-t-yellow/80"></div>
        <div class="w-2.5 h-2.5 rounded-full bg-t-green/80"></div>
      </div>
      <span id="back-btn" onclick="goBack()"></span>
      <span id="title-bar" class="text-t-dim text-xs flex-1 text-center">owlsh v1.0</span>
      <div id="settings-wrap">
        <span id="settings-btn" onclick="toggleSettings(event)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#e6edf3" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg></span>
        <div id="settings-panel">
          <div class="settings-row" onclick="toggleMute()">
            <span id="s-mute-row"></span>
          </div>
          <div class="settings-row" onclick="toggleInputMode()">
            <span id="s-mode-row"></span>
          </div>
          <div class="settings-divider"></div>
          <div class="settings-label">Level</div>
          <div id="s-levels"></div>
        </div>
      </div>
    </div>

    <!-- Terminal body -->
    <div id="terminal-body" class="border border-t-0 border-t-border rounded-b-lg bg-t-bg relative flex flex-col min-h-0 flex-1">
      <div class="absolute inset-0 pointer-events-none scanlines"></div>
      <pre id="screen" class="px-4 sm:px-6 pt-4 pb-2 text-t-fg text-[16px] sm:text-[18px] leading-[1.6] whitespace-pre-wrap fade-in flex-1 min-h-0 overflow-y-auto"></pre>
      <div id="tap-area" class="hidden shrink-0"></div>
      <div id="input-bar" class="flex items-center px-4 sm:px-6 py-3 border-t border-t-border shrink-0">
        <span class="text-t-accent font-bold mr-2 text-base sm:text-lg">‚ùØ</span>
        <input
          id="input"
          type="text"
          class="bg-transparent text-t-fg text-base sm:text-lg outline-none flex-1 caret-t-accent placeholder:text-t-dim/40 font-mono"
          autofocus
          autocomplete="off"
          autocapitalize="off"
          spellcheck="false"
          placeholder="Type here..."
        />
      </div>
    </div>
    <div class="text-center mt-1 text-t-dim text-[10px] shrink-0">built with care</div>
  </div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  owlsh ‚Äî Sight Words Terminal Game
//  All game modes ‚Ä¢ Adaptive difficulty ‚Ä¢ Profile tracking
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚îÄ‚îÄ‚îÄ WORD DATA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const LEVELS = [
  { key: 'hatchling', name: 'Hatchling',  icon: 'ü•í', desc: 'Just starting out' },
  { key: 'fledgling', name: 'Fledgling',  icon: 'üê£', desc: 'Learning the basics' },
  { key: 'flyer',     name: 'Flyer',      icon: 'üê•', desc: 'Taking flight' },
  { key: 'soarer',    name: 'Soarer',     icon: 'ü¶Ö', desc: 'Riding the winds' },
  { key: 'owl',       name: 'Owl Master', icon: 'ü¶â', desc: 'Wise and masterful' },
];

const WORDS = {
  hatchling: ['a','and','away','big','blue','can','come','down','find','for','funny','go','help','here','I','in','is','it','jump','little','look','make','me','my','not','one','play','red','run','said','see','the','three','to','two','up','we','where','yellow','you'],
  fledgling: ['all','am','are','at','ate','be','black','brown','but','came','did','do','eat','four','get','good','have','he','into','like','must','new','no','now','on','our','out','please','pretty','ran','ride','saw','say','she','so','soon','that','there','they','this','too','under','want','was','well','went','what','white','who','will','with','yes'],
  flyer: ['after','again','an','any','as','ask','by','could','every','fly','from','give','going','had','has','her','him','his','how','just','know','let','live','may','of','old','once','open','over','put','round','some','stop','take','thank','them','then','think','walk','were','when'],
  soarer: ['always','around','because','been','before','best','both','buy','call','cold','does','don\'t','fast','first','five','found','gave','goes','green','its','made','many','off','or','pull','read','right','sing','sit','sleep','tell','their','these','those','upon','us','use','very','wash','which','why','wish','work','would','write','your'],
  owl: ['about','better','bring','carry','clean','cut','done','draw','drink','eight','fall','far','full','got','grow','hold','hot','hurt','if','keep','kind','laugh','light','long','much','myself','never','only','own','pick','seven','shall','show','six','small','start','ten','today','together','try','warm'],
};

const SENTENCES = {
  // Hatchling
  a:['I see ___ cat.','She ate ___ big apple.','I want ___ new toy.'],
  and:['Mom ___ Dad are here.','Cats ___ dogs are pets.','I ran ___ I jumped.'],
  away:['Go ___!','Run ___!','Put it ___.'],
  big:['That is a ___ house.','I see a ___ dog.','What a ___ tree!'],
  blue:['The sky is ___.','I have a ___ hat.','The ___ bird sings.'],
  can:['I ___ jump high.','She ___ run fast.','You ___ do it!'],
  come:['___ here please!','___ play with me!','___ see this!'],
  down:['Sit ___.','Go ___ the hill.','Put it ___.'],
  find:['Can you ___ it?','Help me ___ my toy.','I will ___ the way.'],
  for:['This is ___ you.','I made it ___ Mom.','A gift ___ my friend.'],
  funny:['That is so ___!','The ___ dog ran.','What a ___ joke!'],
  go:['Let us ___!','Time to ___ home.','I want to ___ now.'],
  help:['Can you ___ me?','I need ___ please.','I like to ___ others.'],
  here:['Come over ___.','Put it ___.','I am right ___.'],
  I:['___ am happy today.','___ like to play.','___ can see you.'],
  in:['The cat is ___ the box.','Put it ___ the bag.','I am ___ the house.'],
  is:['She ___ my friend.','It ___ a nice day.','That ___ so cool!'],
  it:['I like ___.','Give ___ to me.','I see ___ now.'],
  jump:['I can ___ high.','___ over it!','The frog can ___.'],
  little:['The ___ bird sings.','I have a ___ cat.','A ___ bug sat here.'],
  look:['___ at that!','___ over here!','Come ___ at this!'],
  make:['Let us ___ a cake.','I will ___ a fort.','Can you ___ it?'],
  me:['Give it to ___.','Play with ___.','Come see ___.'],
  my:['This is ___ book.','I love ___ dog.','Where is ___ hat?'],
  not:['I am ___ sad.','It is ___ here.','She did ___ go.'],
  one:['I have ___ apple.','Just ___ more!','Pick ___ please.'],
  play:['Let us ___!','I want to ___ now.','Come ___ with me.'],
  red:['I see a ___ ball.','The ___ hat is mine.','I like ___ roses.'],
  run:['I can ___ fast.','Let us ___!','The dog will ___.'],
  said:['She ___ hello.','Mom ___ it is time.','He ___ yes!'],
  see:['I can ___ you.','Come ___ the birds.','Do you ___ it?'],
  the:['___ dog is big.','I like ___ sun.','___ cat is soft.'],
  three:['I have ___ cats.','I see ___ birds.','Count to ___.'],
  to:['I want ___ go.','Give it ___ me.','Time ___ eat!'],
  two:['I have ___ hands.','I see ___ ducks.','She has ___ eyes.'],
  up:['Look ___!','Jump ___!','Get ___ now.'],
  we:['___ are friends.','___ like to play.','___ can do it!'],
  where:['___ is the cat?','___ did it go?','___ are you?'],
  yellow:['The ___ sun shines.','I see a ___ bus.','A ___ duck swims.'],
  you:['I like ___.','___ are so nice.','Can ___ see it?'],
  // Fledgling
  all:['We ___ went home.','I ate ___ of it.','They ___ came to play.'],
  am:['I ___ right here.','I ___ so happy.','I ___ ready to go.'],
  are:['You ___ so smart.','They ___ at school.','We ___ best friends.'],
  at:['Look ___ the bird.','I am ___ home.','She is ___ the park.'],
  ate:['I ___ my lunch.','She ___ the cake.','We ___ all the fruit.'],
  be:['I want to ___ kind.','You can ___ brave.','It will ___ fun.'],
  black:['The ___ cat sat.','I see a ___ bird.','She has ___ shoes.'],
  brown:['A ___ bear sleeps.','The ___ dog ran.','I see a ___ leaf.'],
  but:['I like it ___ not now.','I fell ___ I am fine.','She tried ___ missed.'],
  came:['She ___ to play.','He ___ home late.','They ___ to see us.'],
  did:['What ___ you do?','She ___ a good job.','How ___ it go?'],
  do:['What ___ you see?','I can ___ it!','___ you like cats?'],
  eat:['I want to ___.','Time to ___ lunch.','Let us ___ now.'],
  four:['I have ___ toys.','I see ___ birds.','She is ___ years old.'],
  get:['I need to ___ my bag.','Come ___ your hat.','Can I ___ a snack?'],
  good:['That was ___!','You did a ___ job.','It is a ___ day.'],
  have:['I ___ a dog.','You ___ big eyes.','We ___ so much fun.'],
  he:['___ is my friend.','___ likes to run.','___ can jump high.'],
  into:['Jump ___ the pool.','Run ___ the house.','We went ___ the fort.'],
  like:['I ___ to read.','I ___ pizza.','Do you ___ cats?'],
  must:['You ___ be kind.','I ___ go home.','We ___ try hard.'],
  new:['I got a ___ toy.','She has a ___ hat.','Look at my ___ book!'],
  no:['___ thank you.','I have ___ more.','___ way!'],
  now:['Let us go ___.','Do it ___!','I am ready ___.'],
  on:['The book is ___ the table.','Put it ___ top.','I sat ___ the chair.'],
  our:['This is ___ house.','I like ___ class.','___ dog is the best.'],
  out:['Let us go ___.','Come ___ and play.','The sun came ___.'],
  please:['Can I have some ___?','Help me ___.','Come here ___.'],
  pretty:['What a ___ flower!','The ___ bird sings.','She looks so ___.'],
  ran:['The dog ___ fast.','She ___ to school.','I ___ all the way.'],
  ride:['I want to ___ my bike.','Can I ___ with you?','Let us ___ the bus.'],
  saw:['I ___ a bird.','She ___ the rainbow.','We ___ a big fish.'],
  say:['What did you ___?','I ___ thank you.','Can you ___ it again?'],
  she:['___ is my sister.','___ likes to sing.','___ ran very fast.'],
  so:['I am ___ happy!','It was ___ much fun.','She is ___ kind.'],
  soon:['We will go ___.','It will be done ___.','Come back ___.'],
  that:['I like ___ one.','Look at ___!','What is ___?'],
  there:['Look over ___!','I was right ___.','Go over ___ now.'],
  they:['___ are playing.','___ like ice cream.','___ went to the park.'],
  this:['I want ___ one.','Look at ___!','___ is the best.'],
  too:['I want to come ___!','Me ___!','It is ___ hot.'],
  under:['The cat is ___ the bed.','Look ___ the table.','It hid ___ a leaf.'],
  want:['I ___ to play.','I ___ a snack.','Do you ___ to come?'],
  was:['It ___ so fun.','She ___ here first.','The day ___ sunny.'],
  well:['I feel ___.','She sings ___.','All is ___ now.'],
  went:['We ___ to the park.','He ___ home early.','They ___ to the zoo.'],
  what:['___ is that?','___ a fun day!','___ do you see?'],
  white:['A ___ rabbit hops.','The ___ snow falls.','I see a ___ cloud.'],
  who:['___ is that?','___ wants to play?','___ can help me?'],
  will:['I ___ help you.','She ___ come soon.','It ___ be fun.'],
  with:['Come ___ me.','Play ___ us.','I went ___ Dad.'],
  yes:['___ I can!','___ please!','She said ___!'],
  // Flyer
  after:['We play ___ lunch.','Come ___ me.','I nap ___ school.'],
  again:['Do it ___!','Let us play ___.','Say it ___ please.'],
  an:['I ate ___ apple.','I saw ___ owl.','She has ___ idea.'],
  any:['Do you have ___ pets?','Is there ___ left?','I like ___ color.'],
  as:['Fast ___ the wind!','Big ___ a bear.','Soft ___ a cloud.'],
  ask:['I want to ___ you.','May I ___ a question?','Just ___ for help.'],
  by:['Sit ___ me.','Walk ___ the lake.','A book ___ my bed.'],
  could:['I ___ hear the music.','She ___ run all day.','___ you help me?'],
  every:['I read ___ day.','___ kid played.','She smiles ___ time.'],
  fly:['Birds can ___.','I wish I could ___.','Watch it ___ away.'],
  from:['A letter ___ Grandma.','I came ___ school.','A gift ___ a friend.'],
  give:['I will ___ you one.','Please ___ me a turn.','___ it a try.'],
  going:['I am ___ home.','We are ___ to the park.','She is ___ to sing.'],
  had:['I ___ a fun day.','She ___ a big smile.','We ___ so much fun.'],
  has:['She ___ a red hat.','He ___ two dogs.','The cake ___ sprinkles.'],
  her:['That is ___ book.','I gave ___ a hug.','___ mom is nice.'],
  him:['I gave it to ___.','Call ___ over here.','Tell ___ the news.'],
  his:['That is ___ dog.','I like ___ shoes.','___ smile is big.'],
  how:['___ are you today?','___ did you do that?','___ many do you see?'],
  just:['I ___ got here.','It is ___ right.','She ___ smiled.'],
  know:['I ___ the answer!','Do you ___?','I ___ you can do it.'],
  let:['___ me try it.','___ us go now.','___ her play too.'],
  live:['I ___ in a house.','Fish ___ in water.','We ___ near a park.'],
  may:['You ___ go now.','___ I have one?','It ___ rain today.'],
  of:['A cup ___ water.','A box ___ toys.','A pair ___ socks.'],
  old:['The ___ tree is tall.','My ___ toy broke.','She is six years ___.'],
  once:['I went there ___.','___ upon a time.','Try it just ___.'],
  open:['Please ___ the door.','___ your eyes.','The box is ___.'],
  over:['Jump ___ the rock.','Come ___ here.','It is ___ now.'],
  put:['___ it down gently.','___ on your coat.','I ___ it away.'],
  round:['The ball is ___.','We went ___ and ___.','A ___ moon shines.'],
  some:['I want ___ water.','Here are ___ toys.','May I have ___?'],
  stop:['Please ___ running.','___ and look.','We need to ___.'],
  take:['___ my hand.','___ a big step.','Please ___ one.'],
  thank:['___ you so much!','I ___ my teacher.','___ you for the gift.'],
  them:['I gave it to ___.','Tell ___ to come.','I like ___ a lot.'],
  then:['First eat ___ play.','We sang ___ danced.','I woke up ___ smiled.'],
  think:['I ___ it is fun.','I ___ you are right.','Let me ___ about it.'],
  walk:['Let us ___ to school.','I like to ___ the dog.','We ___ every morning.'],
  were:['They ___ very happy.','We ___ at the zoo.','The kids ___ so loud.'],
  when:['___ is your birthday?','I smile ___ I play.','___ can we go?'],
  // Soarer
  always:['I ___ brush my teeth.','She ___ shares her toys.','We ___ say please.'],
  around:['We ran ___ the park.','Look ___ you.','Turn ___ in a circle.'],
  because:['I smiled ___ I was happy.','We stayed in ___ it rained.','I like her ___ she is kind.'],
  been:['I have ___ there before.','She has ___ so kind.','Have you ___ to the zoo?'],
  before:['Wash hands ___ you eat.','I read ___ bed.','Think ___ you act.'],
  best:['You are the ___!','That was the ___ day.','She is my ___ friend.'],
  both:['We ___ like dogs.','___ of us laughed.','I want ___ please.'],
  buy:['I want to ___ a book.','Can we ___ some fruit?','Mom will ___ it.'],
  call:['I will ___ my friend.','___ me when you can.','Did you ___ her?'],
  cold:['The water is ___.','It is ___ outside.','My hands are ___.'],
  does:['She ___ her homework.','What ___ it mean?','He ___ his best.'],
  'don\'t':['I ___ want to go.','___ forget your bag.','They ___ like bugs.'],
  fast:['The rabbit runs ___.','She swims ___.','How ___ can you go?'],
  first:['I was ___ in line.','___ we eat then play.','She came in ___.'],
  five:['I have ___ fingers.','Count to ___.','There are ___ ducks.'],
  found:['I ___ my toy!','She ___ a shell.','We ___ a nice spot.'],
  gave:['She ___ me a hug.','He ___ us a ride.','I ___ my friend a gift.'],
  goes:['He ___ to school.','She ___ to the park.','The bell ___ ring!'],
  green:['The frog is ___.','I see ___ leaves.','She has a ___ hat.'],
  its:['The dog wagged ___ tail.','The bird sang ___ song.','The cat licked ___ paw.'],
  made:['I ___ a drawing.','She ___ her bed.','We ___ a snowman.'],
  many:['How ___ do you have?','So ___ stars shine.','I have ___ friends.'],
  off:['Turn ___ the light.','Take ___ your hat.','Jump ___ the log.'],
  or:['Milk ___ water?','Yes ___ no?','Big ___ small?'],
  pull:['___ the door open.','Help me ___ it.','___ up your socks.'],
  read:['I love to ___ books.','___ it out loud.','She can ___ fast.'],
  right:['You got it ___!','Turn ___ here.','That is the ___ way.'],
  sing:['I like to ___ songs.','Can you ___?','Birds ___ at dawn.'],
  sit:['Please ___ down.','___ by me.','The dog can ___.'],
  sleep:['I need to ___.','Time to go to ___.','The baby will ___ soon.'],
  tell:['Please ___ me a story.','___ me what you see.','Can you ___ her?'],
  their:['That is ___ house.','I like ___ dog.','___ yard is big.'],
  these:['I like ___ shoes.','___ are so pretty.','Look at ___ fish.'],
  those:['Look at ___ birds.','I want ___ ones.','___ are my toys.'],
  upon:['Once ___ a time.','A star shone ___ us.','Sit ___ the chair.'],
  us:['Come play with ___.','Tell ___ a joke.','She helped ___.'],
  use:['I can ___ a pencil.','May I ___ that?','___ your words.'],
  very:['I am ___ happy.','She is ___ tall.','It was ___ cold.'],
  wash:['Please ___ your hands.','I will ___ the cup.','___ the dog today.'],
  which:['___ one do you want?','___ way do we go?','___ color is best?'],
  why:['___ is the sky blue?','Tell me ___.','___ did you go?'],
  wish:['I ___ for a puppy.','Make a ___!','I ___ it was summer.'],
  work:['Let us ___ together.','I like to ___ hard.','Good ___!'],
  would:['I ___ like some cake.','She ___ love this.','___ you help me?'],
  write:['I can ___ my name.','Let me ___ it down.','She will ___ a note.'],
  your:['Is this ___ book?','I like ___ smile.','Tie ___ shoes.'],
  // Owl
  about:['Tell me ___ your day.','What is it ___?','I read ___ animals.'],
  better:['I feel ___ now.','She did even ___.','This one is ___.'],
  bring:['Please ___ your book.','I will ___ the food.','___ it to me.'],
  carry:['I can ___ the bag.','Help me ___ this.','She will ___ her doll.'],
  clean:['My room is ___.','We need to ___ up.','The dish is ___.'],
  cut:['I will ___ the paper.','She ___ the ribbon.','Do not ___ that.'],
  done:['Are you ___ yet?','I am all ___.','When will it be ___?'],
  draw:['I like to ___.','___ a picture.','She can ___ a cat.'],
  drink:['I need a ___ of water.','May I have a ___?','Take a ___ please.'],
  eight:['I am ___ years old.','Count to ___.','There are ___ bees.'],
  fall:['Leaves ___ in autumn.','Do not ___ down.','I love ___ colors.'],
  far:['The park is not ___.','How ___ is it?','It is ___ away.'],
  full:['The cup is ___.','I am ___ now.','The moon is ___.'],
  got:['I ___ a new toy!','She ___ a gold star.','We ___ to go.'],
  grow:['Plants ___ in the sun.','I will ___ big.','Watch the seeds ___.'],
  hold:['Please ___ my hand.','Can you ___ this?','___ on tight!'],
  hot:['The soup is ___.','It is ___ today.','The sand is ___.'],
  hurt:['I hope it does not ___.','My knee ___s.','Did that ___?'],
  if:['We can go ___ it is sunny.','___ you try you can do it.','What ___ it rains?'],
  keep:['I will ___ it safe.','___ going!','You can ___ that.'],
  kind:['She is very ___.','Be ___ to others.','What a ___ thing to do.'],
  laugh:['That joke made me ___.','I love to ___.','We all ___ed.'],
  light:['Turn on the ___.','The bag is ___.','The sun gives us ___.'],
  long:['It has been a ___ day.','How ___ is the line?','We took a ___ walk.'],
  much:['Thank you so ___!','How ___ is it?','I like you so ___.'],
  myself:['I did it all by ___!','I made it ___.','I can tie my shoes by ___.'],
  never:['I have ___ seen snow.','___ give up!','She ___ stops smiling.'],
  only:['I have ___ one left.','She is the ___ one.','It takes ___ a minute.'],
  own:['I have my ___ room.','She has her ___ bike.','I made my ___ lunch.'],
  pick:['Please ___ a color.','___ up your toys.','I will ___ this one.'],
  seven:['There are ___ days.','I am ___ years old.','She ate ___ grapes.'],
  shall:['We ___ go together.','___ we dance?','What ___ we do?'],
  show:['Let me ___ you.','___ and tell is fun.','Can you ___ me how?'],
  six:['I have ___ crayons.','She is ___ years old.','I see ___ ducks.'],
  small:['The mouse is ___.','A ___ seed grows big.','I have a ___ cat.'],
  start:['Let us ___ the game!','Ready to ___?','___ from the top.'],
  ten:['I can count to ___.','We need ___ more.','There are ___ in all.'],
  today:['I am happy ___.','___ is a good day.','What did you do ___?'],
  together:['We play ___.','Let us sing ___.','We are ___ again.'],
  try:['I will ___ my best.','___ it one more time.','Let me ___ that.'],
  warm:['The sun feels ___.','Put on a ___ coat.','The blanket is ___.'],
};

// ‚îÄ‚îÄ‚îÄ ASCII ART ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Block-character owl ‚Äî renders cleanly in all monospace fonts
const OWL = {
  idle: `    ‚ñÑ‚ñà‚ñà‚ñà‚ñÑ
   ‚ñà ‚óâ ‚óâ ‚ñà
    ‚ñà ‚ñæ ‚ñà
    ‚ñÄ‚ñà‚ñà‚ñà‚ñÄ
     ‚ñà ‚ñà
    ‚ñÄ   ‚ñÄ`,
  happy: `    ‚ñÑ‚ñà‚ñà‚ñà‚ñÑ
   ‚ñà ‚óï‚Äø‚óï ‚ñà
    ‚ñà   ‚ñà
    ‚ñÄ‚ñà‚ñà‚ñà‚ñÄ
     ‚ñà ‚ñà
    ‚ñÄ   ‚ñÄ`,
  celebrate: `  ‚ú¶ ‚ñÑ‚ñà‚ñà‚ñà‚ñÑ ‚ú¶
   ‚ñà ‚óï‚ó°‚óï ‚ñà
    ‚ñà   ‚ñà
    ‚ñÄ‚ñà‚ñà‚ñà‚ñÄ
    ‚ñà   ‚ñà
   ‚ñÄ     ‚ñÄ`,
  think: `    ‚ñÑ‚ñà‚ñà‚ñà‚ñÑ  ¬∑
   ‚ñà ‚óâ ‚óâ ‚ñà¬∑
    ‚ñà - ‚ñà
    ‚ñÄ‚ñà‚ñà‚ñà‚ñÄ
     ‚ñà ‚ñà
    ‚ñÄ   ‚ñÄ`,
  encourage: `    ‚ñÑ‚ñà‚ñà‚ñà‚ñÑ
   ‚ñà ‚óâ ‚óâ ‚ñà
    ‚ñà ‚ó° ‚ñà
    ‚ñÄ‚ñà‚ñà‚ñà‚ñÄ
     ‚ñà ‚ñà
    ‚ñÄ   ‚ñÄ`,
};

// Big block title for welcome screen (from oh-my-logo)
const LOGO = ` ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë
‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë
 ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù`;

const AVATARS = [
  { id: 'owl',    face: '{‚óâ,‚óâ}', name: 'Owl' },
  { id: 'cat',    face: '(^.^)',  name: 'Cat' },
  { id: 'bear',   face: ' ï‚Ä¢·¥•‚Ä¢ î', name: 'Bear' },
  { id: 'bunny',  face: '(‚óï.‚óï)', name: 'Bunny' },
  { id: 'fox',    face: '(‚Ä¢·¥ó‚Ä¢)', name: 'Fox' },
];

const CHEERS = ['Amazing!','Fantastic!','Brilliant!','Superb!','Nailed it!','Perfect!','Outstanding!','Wonderful!','Great job!','You rock!'];
const NUDGES = ['Almost!','Try again!','So close!','You got this!','Keep going!','One more try!','Almost there!','Don\'t give up!'];

const MODES = [
  { key: 'flash',    name: 'Flash',    emoji: '‚ú¶', ico: 'zap',      desc: 'See it, remember it, tap it' },
  { key: 'fill',     name: 'Fill',     emoji: '‚óß', ico: 'puzzle',   desc: 'Complete the missing letters' },
  { key: 'scramble', name: 'Scramble', emoji: '‚óà', ico: 'shuffle',  desc: 'Unscramble the jumbled letters' },
  { key: 'rush',     name: 'Rush',     emoji: '‚ñ∂', ico: 'timer',    desc: 'Tap fast ‚Äî beat the clock!' },
  { key: 'story',    name: 'Story',    emoji: '‚ñ§', ico: 'bookOpen', desc: 'Fill the blank in a sentence' },
];

// ‚îÄ‚îÄ‚îÄ AUDIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let actx;
function initAudio() {
  if (!actx) actx = new AudioCtx();
  if (actx.state === 'suspended') actx.resume();
}
let muted = localStorage.getItem('owlsh_muted') === '1';
function toggleMute() {
  muted = !muted;
  localStorage.setItem('owlsh_muted', muted ? '1' : '0');
  render();
}
function toggleInputMode() {
  S.inputMode = S.inputMode === 'tap' ? 'type' : 'tap';
  localStorage.setItem('owlsh_inputMode', S.inputMode);
  render();
}
function toggleSettings(e) {
  if (e) { e.stopPropagation(); }
  const panel = $('settings-panel');
  panel.classList.toggle('open');
}
function closeSettings() {
  $('settings-panel').classList.remove('open');
}
function setLevel(lvl) {
  if (isInActiveGame()) return;
  const profile = getActiveProfile();
  if (!profile) return;
  S.level = lvl;
  profile.level = lvl;
  saveActiveProfile(profile);
  closeSettings();
  render();
}
function isInActiveGame() {
  return S.screen === 'game' || S.screen === 'discovery';
}
function tone(freq, dur, type = 'sine', vol = 0.12) {
  if (!actx || muted) return;
  const o = actx.createOscillator(), g = actx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.value = vol;
  g.gain.exponentialRampToValueAtTime(0.001, actx.currentTime + dur);
  o.connect(g); g.connect(actx.destination);
  o.start(); o.stop(actx.currentTime + dur);
}
function sndCorrect() { tone(523,0.1); setTimeout(()=>tone(659,0.1),70); setTimeout(()=>tone(784,0.15),140); }
function sndWrong()   { tone(220,0.25,'triangle',0.08); }
function sndLevelUp() { [523,587,659,698,784].forEach((f,i)=>setTimeout(()=>tone(f,0.12),i*90)); }
function sndTick()    { tone(1000,0.02,'square',0.03); }
function sndRush()    { tone(440,0.08,'sawtooth',0.06); }

// ‚îÄ‚îÄ‚îÄ 8-BIT MUSIC ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Daft Punk meets Mario Bros ‚Äî chiptune intro & transitions
// Lead = square wave (NES pulse channel), Bass = triangle wave,
// Perc = short noise bursts. All scheduled via Web Audio API.
function chipNote(freq, start, dur, type = 'square', vol = 0.07) {
  if (!actx || muted) return;
  const t = actx.currentTime + start;
  const o = actx.createOscillator(), g = actx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.setValueAtTime(vol, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + dur * 0.9);
  o.connect(g); g.connect(actx.destination);
  o.start(t); o.stop(t + dur);
}
function chipNoise(start, dur, vol = 0.04) {
  if (!actx || muted) return;
  const t = actx.currentTime + start;
  const buf = actx.createBuffer(1, actx.sampleRate * dur, actx.sampleRate);
  const d = buf.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
  const n = actx.createBufferSource(), g = actx.createGain();
  n.buffer = buf;
  g.gain.setValueAtTime(vol, t);
  g.gain.exponentialRampToValueAtTime(0.001, t + dur * 0.8);
  n.connect(g); g.connect(actx.destination);
  n.start(t); n.stop(t + dur);
}

// Main intro ‚Äî plays on first enter (welcome ‚Üí profiles)
// ~2.5 sec, 150 BPM, two bars of funky chiptune
function sndIntro() {
  if (!actx || muted) return;
  const bpm = 150, s = 60 / bpm / 4; // sixteenth note duration

  // Lead melody (square) ‚Äî bouncy Mario-style arpeggio w/ Daft Punk repetition
  // Bar 1: ascending arpeggio + punchy repeat
  // Bar 2: variation with higher peak
  const lead = [
    // bar 1
    [523,0],[659,2],[784,4],[1047,5],[784,6],[659,7],
    [523,8],[659,10],[784,11],[1047,12],[1175,13],[1047,14],
    // bar 2 ‚Äî funkier rhythm
    [784,16],[784,18],[1047,19],[784,20],[659,21],[784,22],
    [523,24],[659,25],[784,26],[1047,27],[1319,28],[1047,30],
  ];
  lead.forEach(([f, p]) => chipNote(f, p * s, s * 1.6, 'square', 0.055));

  // Bass (triangle) ‚Äî Daft Punk-style pumping root + fifth
  const bass = [
    [131,0],[131,4],[196,6],[131,8],[131,12],[196,14],
    [175,16],[175,20],[196,22],[131,24],[131,28],[196,30],
  ];
  bass.forEach(([f, p]) => chipNote(f, p * s, s * 3, 'triangle', 0.09));

  // Percussion ‚Äî kick + hi-hat pattern
  for (let i = 0; i < 32; i += 4) chipNoise(i * s, 0.05, 0.06);       // kick
  for (let i = 2; i < 32; i += 4) chipNoise(i * s, 0.02, 0.025);      // hi-hat
  for (let i = 8; i < 32; i += 8) chipNoise((i) * s, 0.08, 0.045);    // snare
}

// Short transition jingle ‚Äî plays between major screens
// ~0.6 sec ascending 4-note arpeggio
function sndTransition() {
  if (!actx || muted) return;
  const s = 0.07;
  [[523,0],[659,1],[784,2],[1047,3]].forEach(([f,p]) =>
    chipNote(f, p * s, s * 2.5, 'square', 0.045)
  );
  chipNote(131, 0, s * 4, 'triangle', 0.06);
}

// Game start fanfare ‚Äî quick 3-note punch
function sndGameStart() {
  if (!actx || muted) return;
  chipNote(523, 0, 0.08, 'square', 0.05);
  chipNote(659, 0.1, 0.08, 'square', 0.05);
  chipNote(1047, 0.2, 0.2, 'square', 0.06);
  chipNote(131, 0, 0.3, 'triangle', 0.07);
}

// ‚îÄ‚îÄ‚îÄ STORE (localStorage) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Schema is versioned. On load, migrations run sequentially from
// the stored version up to STORE_VERSION. To evolve the schema:
//   1. Bump STORE_VERSION
//   2. Add a migration function to MIGRATIONS[newVersion]
//   3. The migration receives the store object and mutates it
// Mastery is keyed by word string (e.g. profile.mastery['the']),
// so adding new words to WORDS is safe ‚Äî they start unmastered.
// profile.level is an index into LEVELS ‚Äî reordering LEVELS
// requires a migration to remap indices.
const STORE_KEY = 'owlsh_data';
const STORE_VERSION = 1;

const MIGRATIONS = {
  // v0 ‚Üí v1: add version field, ensure profile shape
  1: (store) => {
    store.profiles.forEach(p => {
      if (!p.stats) p.stats = { totalScore: 0, wordsLearned: 0, sessionsPlayed: 0, bestStreak: 0 };
      if (!p.mastery) p.mastery = {};
      if (!p.created) p.created = Date.now();
    });
  },
  // Future migrations go here:
  // 2: (store) => { /* e.g. remap level indices after reorder */ },
};

function migrateStore(store) {
  const from = store._v || 0;
  for (let v = from + 1; v <= STORE_VERSION; v++) {
    if (MIGRATIONS[v]) MIGRATIONS[v](store);
  }
  store._v = STORE_VERSION;
  return store;
}

function freshStore() {
  return { _v: STORE_VERSION, profiles: [], activeProfile: null };
}

function loadStore() {
  try {
    const raw = JSON.parse(localStorage.getItem(STORE_KEY));
    if (!raw) return freshStore();
    return migrateStore(raw);
  } catch {
    return freshStore();
  }
}

function saveStore(data) {
  data._v = STORE_VERSION;
  localStorage.setItem(STORE_KEY, JSON.stringify(data));
}

function getActiveProfile() {
  const store = loadStore();
  if (store.activeProfile === null) return null;
  return store.profiles[store.activeProfile] || null;
}

function saveActiveProfile(profile) {
  const store = loadStore();
  if (store.activeProfile !== null) {
    store.profiles[store.activeProfile] = profile;
    saveStore(store);
  }
}

function createProfile(name, avatarId) {
  const store = loadStore();
  const profile = {
    name,
    avatar: avatarId,
    level: null, // null = needs discovery
    mastery: {},  // { word: { seen, correct, streak, stars } }
    stats: { totalScore: 0, wordsLearned: 0, sessionsPlayed: 0, bestStreak: 0 },
    created: Date.now(),
  };
  store.profiles.push(profile);
  store.activeProfile = store.profiles.length - 1;
  saveStore(store);
  return profile;
}

function setActiveProfileIndex(idx) {
  const store = loadStore();
  store.activeProfile = idx;
  saveStore(store);
}

function getWordMastery(profile, word) {
  return profile.mastery[word] || { seen: 0, correct: 0, streak: 0, stars: 0 };
}

function updateMastery(profile, word, wasCorrect) {
  const m = getWordMastery(profile, word);
  m.seen++;
  if (wasCorrect) {
    m.correct++;
    m.streak++;
    if (m.streak >= 3 && m.stars < 5) m.stars = Math.min(5, m.stars + 1);
  } else {
    m.streak = 0;
    if (m.stars > 0) m.stars = Math.max(0, m.stars - 1);
  }
  profile.mastery[word] = m;
  saveActiveProfile(profile);
}

// ‚îÄ‚îÄ‚îÄ STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let S = {
  screen: 'welcome',
  inputMode: localStorage.getItem('owlsh_inputMode') || 'tap',
  // profile creation
  newName: '',
  newAvatar: 0,
  // game
  level: 0,
  mode: 0,
  words: [],
  wordIdx: 0,
  score: 0,
  streak: 0,
  bestStreak: 0,
  correct: 0,
  results: [],
  phase: 'show', // flash mode: 'show' | 'type'
  attempts: 0,
  hint: '',
  timer: null,
  // tap mode
  choices: [],
  selectedLetters: [],
  availableLetters: [],
  tappedCard: null,
  _filledLetters: [],
  _storySentence: null,
  _storyWord: null,
  // rush mode
  rushTime: 60,
  rushTimer: null,
  rushActive: false,
  // discovery
  discoveryWords: [],
  discoveryResults: [],
  discoveryIdx: 0,
  discoveryPhase: 'show',
  discoveryChoices: [],
  // feedback
  lastCorrect: false,
  lastWord: '',
  // misc
  inputEnabled: true,
  deleteProfileIdx: null,
};

// ‚îÄ‚îÄ‚îÄ UI HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const $ = id => document.getElementById(id);
let W = 58; // content width in characters (updated dynamically)

function updateW() {
  const scr = $('screen');
  if (!scr || !scr.clientWidth) return;
  const style = getComputedStyle(scr);
  const contentPx = scr.clientWidth - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight);
  const ruler = document.createElement('span');
  ruler.style.cssText = 'position:absolute;visibility:hidden;white-space:pre';
  ruler.textContent = '0000000000';
  scr.appendChild(ruler);
  const chPx = ruler.getBoundingClientRect().width / 10;
  scr.removeChild(ruler);
  if (chPx > 0) W = Math.floor(contentPx / chPx);
}

function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }
// Inline SVG icons (Lucide-style, 24x24 viewBox)
const ICONS = {
  play:      '<path d="M6 3l14 9-14 9V3z"/>',
  compass:   '<circle cx="12" cy="12" r="10"/><path d="M16.24 7.76l-2.12 6.36-6.36 2.12 2.12-6.36z"/>',
  barChart:  '<path d="M18 20V10M12 20V4M6 20v-6"/>',
  helpCircle:'<circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><circle cx="12" cy="17" r=".5"/>',
  zap:       '<path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>',
  puzzle:    '<path d="M19.439 7.85c-.049.322.059.648.289.878l1.568 1.568c.47.47.706 1.087.706 1.704s-.235 1.233-.706 1.704l-1.611 1.611a.98.98 0 0 1-.837.276c-.47-.07-.802-.48-.968-.925a2.501 2.501 0 1 0-3.214 3.214c.446.166.855.497.925.968a.979.979 0 0 1-.276.837l-1.61 1.61a2.404 2.404 0 0 1-1.705.707 2.402 2.402 0 0 1-1.704-.706l-1.568-1.568a1.026 1.026 0 0 0-.877-.29c-.493.074-.84.504-1.02.968a2.5 2.5 0 1 1-3.237-3.237c.464-.18.894-.527.967-1.02a1.026 1.026 0 0 0-.289-.877l-1.568-1.568A2.402 2.402 0 0 1 1.998 12c0-.617.236-1.234.706-1.704L4.23 8.77c.24-.24.581-.353.917-.303.515.077.877.528 1.073 1.01a2.5 2.5 0 1 0 3.259-3.259c-.482-.196-.933-.558-1.01-1.073-.05-.336.062-.676.303-.917l1.525-1.525A2.402 2.402 0 0 1 12 1.998c.617 0 1.234.236 1.704.706l1.568 1.568c.23.23.556.338.877.29.493-.074.84-.504 1.02-.968a2.5 2.5 0 1 1 3.237 3.237c-.464.18-.894.527-.967 1.02z"/>',
  shuffle:   '<path d="M2 18h1.4c1.3 0 2.5-.6 3.3-1.7l6.1-8.6c.7-1.1 2-1.7 3.3-1.7H18M18 2l4 4-4 4"/><path d="M2 6h1.9c1.5 0 2.9.9 3.6 2.2M16.8 15.8c-.8 1.2-2.1 2.2-3.6 2.2H18M18 14l4 4-4 4"/>',
  timer:     '<path d="M10 2h4"/><path d="M12 14V10"/><circle cx="12" cy="14" r="8"/>',
  bookOpen:  '<path d="M12 7c-1.5-1.5-3.5-2-5-2s-3.5.5-5 2v12c1.5-1 3-1.5 5-1.5s3.5.5 5 1.5M12 7c1.5-1.5 3.5-2 5-2s3.5.5 5 2v12c-1.5-1-3-1.5-5-1.5s-3.5.5-5 1.5"/>',
  chevronLeft:'<path d="M15 18l-6-6 6-6"/>',
  volume2:   '<path d="M11 5L6 9H2v6h4l5 4V5z"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/>',
  volumeX:   '<path d="M11 5L6 9H2v6h4l5 4V5z"/><line x1="22" y1="9" x2="16" y2="15"/><line x1="16" y1="9" x2="22" y2="15"/>',
  hand:      '<path d="M18 11V6a2 2 0 0 0-4 0v4M14 10V4a2 2 0 0 0-4 0v7M10 10.5V2a2 2 0 0 0-4 0v9"/><path d="M7 15.172A4 4 0 0 1 6 12.828V11a2 2 0 0 0-4 0v1a10 10 0 0 0 10 10h1a6 6 0 0 0 6-6v-2a2 2 0 0 0-4 0"/>',
  keyboard:  '<rect x="2" y="4" width="20" height="16" rx="2"/><path d="M6 8h.01M10 8h.01M14 8h.01M18 8h.01M8 12h.01M12 12h.01M16 12h.01M7 16h10"/>',
  undo:      '<path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>',
  arrowLeft: '<path d="M19 12H5M12 19l-7-7 7-7"/>',
  rotateCcw: '<path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/>',
  trash2:    '<path d="M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/>',
  settings:  '<path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/>',
};
function icon(name, size = 16, color = '#e6edf3') {
  return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:inline-block;vertical-align:middle">${ICONS[name] || ''}</svg>`;
}
function tc(text, color) { return `<span class="text-t-${color}">${text}</span>`; }
function tb(text) { return `<span class="font-bold">${text}</span>`; }
function tdim(text) { return tc(text, 'dim'); }

function center(text) {
  const stripped = text.replace(/<[^>]*>/g, '');
  const pad = Math.max(0, Math.floor((W - stripped.length) / 2));
  return ' '.repeat(pad) + text;
}

function centerBlock(text) {
  const lines = text.split('\n');
  const maxLen = Math.max(...lines.map(l => l.replace(/<[^>]*>/g, '').length));
  const pad = Math.max(0, Math.floor((W - maxLen) / 2));
  return lines.map(l => ' '.repeat(pad) + l).join('\n');
}

function hr(ch = '‚îÄ') { return `<span style="color:#21262d">${ch.repeat(W)}</span>`; }

function progressBar(cur, total, w = 20) {
  const filled = Math.round((cur / Math.max(total, 1)) * w);
  return tc('‚ñà'.repeat(filled), 'green') + tdim('‚ñë'.repeat(w - filled));
}

function stars(n, max = 5) {
  return tc('‚òÖ'.repeat(n), 'yellow') + tdim('‚òÜ'.repeat(max - n));
}

function opt(key, label) {
  return `  ${tc('[' + key + ']', 'yellow')}  ${label}`;
}

function owlArt(mood = 'idle') { return OWL[mood] || OWL.idle; }

function rand(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// ‚îÄ‚îÄ‚îÄ WORD SELECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function pickWords(levelKey, count = 10) {
  const profile = getActiveProfile();
  const pool = [...WORDS[levelKey]];
  // Sort by mastery (ascending) so weaker words appear first
  pool.sort((a, b) => {
    const mA = getWordMastery(profile, a).stars;
    const mB = getWordMastery(profile, b).stars;
    if (mA !== mB) return mA - mB;
    return Math.random() - 0.5;
  });
  return shuffle(pool.slice(0, Math.min(count, pool.length)));
}

function makeMissing(word) {
  const chars = word.split('');
  const hide = Math.max(1, Math.ceil(chars.length * 0.4));
  const idxs = shuffle(chars.map((_, i) => i)).slice(0, hide);
  const set = new Set(idxs);
  return chars.map((c, i) => set.has(i) ? '_' : c).join('');
}

function makeScramble(word) {
  if (word.length <= 2) return word.split('').reverse().join('');
  let s; let tries = 0;
  do { s = shuffle(word.split('')).join(''); tries++; } while (s === word && tries < 30);
  return s;
}

// ‚îÄ‚îÄ‚îÄ DISTRACTOR GENERATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function generateDistractors(word, count, levelKey) {
  const pool = WORDS[levelKey].filter(w => w !== word);
  // Sort candidates: prefer similar length, then same starting letter
  const scored = pool.map(w => {
    let s = 0;
    if (Math.abs(w.length - word.length) <= 1) s += 3;
    else if (Math.abs(w.length - word.length) <= 2) s += 1;
    if (w[0] === word[0]) s += 2; // tricky same-start distractor
    s += Math.random(); // randomize within tiers
    return { w, s };
  });
  scored.sort((a, b) => b.s - a.s);

  const result = [];
  // Take one same-start-letter distractor if available
  const sameStart = scored.find(x => x.w[0] === word[0]);
  if (sameStart) result.push(sameStart.w);

  // Fill remaining from scored list
  for (const { w } of scored) {
    if (result.length >= count) break;
    if (!result.includes(w)) result.push(w);
  }

  // Fall back to adjacent levels if not enough
  if (result.length < count) {
    const levelKeys = Object.keys(WORDS);
    const idx = levelKeys.indexOf(levelKey);
    const adjacent = [idx - 1, idx + 1].filter(i => i >= 0 && i < levelKeys.length);
    for (const ai of adjacent) {
      const extra = WORDS[levelKeys[ai]].filter(w => w !== word && !result.includes(w));
      for (const w of shuffle(extra)) {
        if (result.length >= count) break;
        result.push(w);
      }
    }
  }

  return shuffle(result.slice(0, count));
}

// ‚îÄ‚îÄ‚îÄ SCREENS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function screenWelcome() {
  const logo = centerBlock(LOGO.split('\n').map(l => tc(l, 'accent')).join('\n'));
  const text = [
    '',
    `<span class="logo-wrap">${logo}</span>`,
    center(tdim('sight words terminal')),
    '',
    centerBlock(owlArt('idle')),
    '',
    center(tc('Learn sight words, one tap at a time.', 'dim')),
    '',
  ].join('\n');
  const cards = `<div style="padding:8px 0"><div class="tap-btn-large" data-action="">TAP TO START</div></div>`;
  return { text, cards };
}

function screenProfiles() {
  const store = loadStore();
  const profiles = store.profiles;
  const text = ['', tb('  Who is playing?'), ''].join('\n');

  let cardItems = '';
  if (profiles.length === 0) {
    cardItems = `<div style="display:flex;flex-direction:column;gap:8px;padding:8px 0">
      <div class="profile-card" data-action="+"><span class="avatar" style="font-size:24px">+</span><span class="name">Create new profile</span></div>
    </div>`;
  } else {
    cardItems = '<div style="display:flex;flex-direction:column;gap:8px;padding:8px 0">';
    profiles.forEach((p, i) => {
      const av = AVATARS.find(a => a.id === p.avatar) || AVATARS[0];
      const lvl = p.level !== null ? LEVELS[p.level].name : 'New';
      cardItems += `<div class="profile-card" data-action="${i + 1}"><span class="avatar">${av.face}</span><span class="name" style="flex:1">${esc(p.name)}</span><span class="level">${lvl}</span><span data-action="delete-${i}" style="padding:4px;opacity:0.4" onclick="event.stopPropagation()">${icon('trash2',14,'#f85149')}</span></div>`;
    });
    if (profiles.length < 5) {
      cardItems += `<div class="profile-card" data-action="+"><span class="avatar" style="font-size:24px">+</span><span class="name">New profile</span></div>`;
    }
    cardItems += '</div>';
  }
  return { text, cards: cardItems };
}

function screenNewProfile() {
  if (!S.newName) {
    // Name entry ‚Äî shows input bar
    const text = ['', tb('  Create Your Profile'), '', hr(), '', '  What should I call you?', '', tdim('  Type your name and press ENTER'), ''].join('\n');
    return { text, cards: '' };
  }
  // Avatar selection + Go button
  const text = ['', tb('  Create Your Profile'), '', hr(), '', `  Name: ${tc(esc(S.newName), 'accent')}`, '', '  Pick your avatar:', ''].join('\n');
  let cards = '<div style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;padding:8px 0">';
  AVATARS.forEach((a, i) => {
    const sel = i === S.newAvatar ? 'border-color:#f4845f;background:rgba(244,132,95,0.1)' : '';
    cards += `<div class="tap-btn" data-action="${i + 1}" style="flex-direction:column;min-width:70px;${sel}"><span style="font-size:22px">${a.face}</span><span style="font-size:11px;color:#484f58">${a.name}</span></div>`;
  });
  cards += '</div>';
  cards += `<div style="padding:8px 0"><div class="tap-btn-large" data-action="go">Go!</div></div>`;
  return { text, cards };
}

function screenMenu() {
  const profile = getActiveProfile();
  if (!profile) return screenProfiles();
  const av = AVATARS.find(a => a.id === profile.avatar) || AVATARS[0];
  const lvlInfo = profile.level !== null ? LEVELS[profile.level] : null;
  const allWords = Object.values(WORDS).flat();
  const mastered = allWords.filter(w => (profile.mastery[w]||{}).stars >= 5).length;

  let lines = [
    '',
    `  ${av.face}  ${tc('Welcome back, ' + esc(profile.name) + '!', 'accent')}`,
    '',
  ];

  if (lvlInfo) {
    lines.push(`  Level: ${tc(lvlInfo.icon + ' ' + lvlInfo.name, 'blue')}  ${tdim('|')}  Mastered: ${tc(mastered + '/' + allWords.length, 'green')}`);
    lines.push(`  ${progressBar(mastered, allWords.length, 30)}`);
  } else {
    lines.push(`  ${tc('New player ‚Äî take the Skill Discovery!', 'yellow')}`);
  }
  lines.push('');

  const text = lines.join('\n');

  let cards = '<div class="menu-grid" style="padding:8px 0">';
  cards += `<div class="menu-card" data-action="1"><span class="icon">${icon('play', 24, '#3fb950')}</span><span>Play</span></div>`;
  cards += `<div class="menu-card" data-action="2"><span class="icon">${icon('compass', 24, '#58a6ff')}</span><span>Discovery</span></div>`;
  cards += `<div class="menu-card" data-action="3"><span class="icon">${icon('barChart', 24, '#bc8cff')}</span><span>Progress</span></div>`;
  cards += `<div class="menu-card" data-action="4"><span class="icon">${icon('helpCircle', 24, '#d29922')}</span><span>How to Play</span></div>`;
  cards += '</div>';

  return { text, cards };
}

function screenLevelSelect() {
  const profile = getActiveProfile();
  const text = ['', tb('  Choose Your Level'), ''].join('\n');

  let cards = '<div style="display:flex;flex-direction:column;gap:8px;padding:8px 0">';
  LEVELS.forEach((lvl, i) => {
    const words = WORDS[lvl.key];
    const mastered = words.filter(w => (profile.mastery[w]||{}).stars >= 5).length;
    const pct = Math.round((mastered / words.length) * 100);
    const current = profile.level === i ? ' style="border-color:#f4845f"' : '';
    cards += `<div class="profile-card" data-action="${i + 1}"${current}>
      <span class="avatar">${lvl.icon}</span>
      <span style="flex:1"><span class="name">${lvl.name}</span><br><span style="font-size:12px;color:#484f58">${pct}% mastered</span></span>
    </div>`;
  });
  cards += '</div>';
  cards += `<div style="padding:8px 0"><div class="tap-btn" data-action="0" style="width:100%;color:#484f58;gap:4px">${icon('chevronLeft',14,'#484f58')} Back</div></div>`;

  return { text, cards };
}

function screenModeSelect() {
  const lvl = LEVELS[S.level];
  const text = ['', `  Level: ${tc(lvl.icon + ' ' + lvl.name, 'blue')}`, '', tb('  Choose Game Mode'), ''].join('\n');

  let cards = '<div class="menu-grid" style="padding:8px 0">';
  MODES.forEach((m, i) => {
    cards += `<div class="menu-card" data-action="${i + 1}"><span class="icon">${icon(m.ico, 24, '#f4845f')}</span><span>${m.name}</span></div>`;
  });
  cards += '</div>';
  cards += `<div style="padding:8px 0"><div class="tap-btn" data-action="0" style="width:100%;color:#484f58">${icon('chevronLeft', 14, '#484f58')} Back</div></div>`;

  return { text, cards };
}

function screenGame() {
  const word = S.words[S.wordIdx];
  const mode = MODES[S.mode];
  const lvl = LEVELS[S.level];
  const isTap = S.inputMode === 'tap';

  // Progress dots (only for non-rush)
  let dots = '';
  if (S.mode !== 3) {
    dots = S.words.map((_, i) => {
      if (i < S.wordIdx) return S.results[i]?.correct ? tc('‚óè', 'green') : tc('‚óè', 'red');
      if (i === S.wordIdx) return tc('‚óâ', 'accent');
      return tdim('‚óã');
    }).join(' ');
  }

  let lines = [];
  let cards = '';

  if (S.mode === 3) {
    // Rush header
    const bar = progressBar(S.rushTime, 60, 30);
    lines = [
      `  ${tc('‚ñ∂ RUSH', 'accent')} ${tdim('‚îÇ')} ${bar} ${tc(S.rushTime + 's', S.rushTime <= 10 ? 'red' : 'blue')}`,
      '',
      `  Score: ${tc(S.score, 'yellow')}  Streak: ${S.streak > 0 ? tc(S.streak, 'accent') : tdim('0')}`,
      '',
      hr(),
      '',
    ];
  } else {
    lines = [
      `  ${tc(lvl.name, 'blue')} ${tdim('‚îÇ')} ${tc(mode.emoji + ' ' + mode.name, 'accent')} ${tdim('‚îÇ')} Score: ${tc(S.score, 'yellow')}`,
      '',
      `  ${dots}`,
      `  Streak: ${S.streak > 0 ? tc(S.streak + ' fire', 'accent') : tdim('0')}`,
      '',
      hr(),
    ];
  }

  if (S.mode === 0) { // Flash
    if (S.phase === 'show') {
      lines.push('');
      lines.push(center(tdim('Look at this word:')));
      lines.push('');
      lines.push(center(tc(tb(word.toUpperCase()), 'fg')));
      lines.push('');
      lines.push(center(tdim('Remember it...')));
      lines.push('');
    } else {
      lines.push('');
      lines.push(center(tc('What was the word?', 'blue')));
      lines.push('');
      if (S.attempts > 0) {
        lines.push(center(tc(rand(NUDGES), 'yellow')));
        if (S.attempts >= 1 && !isTap) {
          const hint = word[0] + '_'.repeat(Math.max(0, word.length - 2)) + (word.length > 1 ? word[word.length-1] : '');
          lines.push(center(tdim('Hint: ' + hint.split('').join(' '))));
        }
        lines.push('');
      }
      if (isTap) {
        cards = renderWordCards(S.choices, word);
      }
    }
  } else if (S.mode === 1) { // Fill
    lines.push('');
    lines.push(center(tdim('Complete the word:')));
    lines.push('');
    if (isTap) {
      // Show slots with filled letters
      const slots = S.hint.split('');
      const filled = S._filledLetters || [];
      let slotHtml = '<div style="display:flex;gap:6px;justify-content:center;padding:4px 0">';
      for (let i = 0; i < slots.length; i++) {
        if (slots[i] === '_') {
          const f = filled.find(x => x.pos === i);
          if (f) {
            slotHtml += `<div class="letter-slot filled">${f.letter.toUpperCase()}</div>`;
          } else {
            slotHtml += `<div class="letter-slot"></div>`;
          }
        } else {
          slotHtml += `<div class="letter-slot given">${slots[i].toUpperCase()}</div>`;
        }
      }
      slotHtml += '</div>';
      lines.push('');
      if (S.attempts > 0) {
        lines.push(center(tc(rand(NUDGES), 'yellow')));
        lines.push('');
      }
      cards = slotHtml + renderLetterTiles(S.availableLetters, true);
    } else {
      lines.push(center(tc(tb(S.hint.split('').join(' ')), 'fg')));
      lines.push('');
      if (S.attempts > 0) {
        lines.push(center(tc(rand(NUDGES), 'yellow')));
        lines.push('');
      }
    }
  } else if (S.mode === 2) { // Scramble
    lines.push('');
    lines.push(center(tdim('Unscramble the letters:')));
    lines.push('');
    if (isTap) {
      // Show target slots
      let slotHtml = '<div style="display:flex;gap:6px;justify-content:center;padding:4px 0">';
      for (let i = 0; i < word.length; i++) {
        const sel = S.selectedLetters[i];
        if (sel) {
          slotHtml += `<div class="letter-slot filled">${sel.letter.toUpperCase()}</div>`;
        } else {
          slotHtml += `<div class="letter-slot"></div>`;
        }
      }
      slotHtml += '</div>';
      lines.push('');
      if (S.attempts > 0) {
        lines.push(center(tc(rand(NUDGES), 'yellow')));
        lines.push('');
      }
      cards = slotHtml + renderLetterTiles(S.availableLetters, true);
    } else {
      lines.push(center(tc(tb(S.hint.split('').join(' ')), 'purple')));
      lines.push(center(tdim(`(${word.length} letters)`)));
      lines.push('');
      if (S.attempts > 0) {
        lines.push(center(tc(rand(NUDGES), 'yellow')));
        lines.push('');
      }
    }
  } else if (S.mode === 3) { // Rush
    if (S.rushActive) {
      lines.push(center(tc(tb(word.toUpperCase()), 'fg')));
      lines.push('');
      if (S.attempts > 0) {
        lines.push(center(tc('Nope! Try again.', 'red')));
        lines.push('');
      }
      if (isTap) {
        cards = renderWordCards(S.choices, word);
      }
    } else {
      lines.push(center(tc('Time is up!', 'yellow')));
      lines.push('');
      lines.push(center(`You got ${tc(S.correct, 'green')} words!`));
      lines.push(center(`Score: ${tc(S.score, 'yellow')}  Best streak: ${tc(S.bestStreak, 'accent')}`));
      lines.push('');
      cards = `<div style="display:flex;flex-direction:column;gap:8px;padding:8px 0">
        <div class="tap-btn-large" data-action="1">${icon('rotateCcw',18,'#f4845f')} Play Again</div>
        <div style="display:flex;gap:8px">
          <div class="tap-btn" data-action="2" style="flex:1">Change Mode</div>
          <div class="tap-btn" data-action="0" style="flex:1;color:#484f58">Menu</div>
        </div>
      </div>`;
    }
  } else if (S.mode === 4) { // Story
    // Use a stable sentence (don't re-randomize on each render)
    if (!S._storySentence || S._storyWord !== word) {
      const pool = SENTENCES[word];
      S._storySentence = pool ? pool[Math.floor(Math.random() * pool.length)] : `The word is ___.`;
      S._storyWord = word;
    }
    const display = S._storySentence.replace('___', tc(tb('___'), 'accent'));
    lines.push('');
    lines.push(center(tdim('Fill in the blank:')));
    lines.push('');
    lines.push(`    "${display}"`);
    lines.push('');
    if (S.attempts > 0) {
      lines.push(center(tc(rand(NUDGES), 'yellow')));
      lines.push('');
    }
    if (isTap) {
      cards = renderWordCards(S.choices, word);
    }
  }

  return { text: lines.join('\n'), cards };
}

// Render 4 word choice cards in a 2x2 grid
function renderWordCards(choices, correctWord) {
  let html = '<div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;padding:8px 0">';
  choices.forEach(w => {
    let extra = '';
    if (S.tappedCard === w) {
      extra = w === correctWord ? ' correct' : ' wrong card-shake';
    }
    html += `<div class="word-card${extra}" data-action="${esc(w)}">${esc(w.toUpperCase())}</div>`;
  });
  html += '</div>';
  return html;
}

// Render letter tiles + undo button
function renderLetterTiles(letters, showUndo) {
  let html = '<div style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;padding:12px 0">';
  letters.forEach((l, i) => {
    const usedClass = l.used ? ' used' : '';
    html += `<div class="letter-tile${usedClass}" data-action="letter-tap" data-letter="${esc(l.letter)}" data-idx="${i}">${l.letter.toUpperCase()}</div>`;
  });
  html += '</div>';
  if (showUndo) {
    html += `<div style="text-align:center;padding:4px 0"><div class="tap-btn" data-action="undo-letter" style="font-size:13px;color:#484f58;display:inline-flex;gap:4px">${icon('undo',14,'#484f58')} Undo</div></div>`;
  }
  return html;
}

function screenFeedback() {
  let lines = [];
  if (S.lastCorrect) {
    lines.push('');
    lines.push(centerBlock(owlArt('happy')));
    lines.push('');
    lines.push(center(tc('‚úì ' + rand(CHEERS), 'green')));
    lines.push('');
    lines.push(center(tc(tb(S.lastWord.toUpperCase()), 'fg')));
    if (S.streak > 1) {
      lines.push('');
      lines.push(center(tc(S.streak + ' in a row!', 'accent')));
    }
  } else {
    lines.push('');
    lines.push(centerBlock(owlArt('encourage')));
    lines.push('');
    lines.push(center(tdim('The word was:')));
    lines.push('');
    lines.push(center(tc(tb(S.lastWord.toUpperCase()), 'fg')));
    lines.push('');
    lines.push(center(tc('You\'ll get it next time!', 'yellow')));
  }
  lines.push('');
  return { text: lines.join('\n'), cards: '' };
}

function screenResults() {
  const profile = getActiveProfile();
  const pct = Math.round((S.correct / Math.max(S.words.length, 1)) * 100);
  const mood = pct >= 80 ? 'celebrate' : pct >= 50 ? 'happy' : 'encourage';

  let lines = [
    '',
    centerBlock(owlArt(mood)),
    '',
    center(tc(tb('Round Complete!'), 'accent')),
    '',
    `  Score: ${tc(S.score, 'yellow')}  Correct: ${tc(S.correct + '/' + S.words.length, pct >= 80 ? 'green' : 'blue')}  Streak: ${tc(S.bestStreak, 'accent')}`,
    '',
    hr(),
    '',
  ];

  S.results.forEach(r => {
    const icon = r.correct ? tc('‚úì', 'green') : tc('‚úó', 'red');
    const m = getWordMastery(profile, r.word);
    lines.push(`  ${icon}  ${r.word.padEnd(12)} ${stars(m.stars)}`);
  });
  lines.push('');

  const text = lines.join('\n');
  let cards = `<div style="display:flex;flex-direction:column;gap:8px;padding:8px 0">
    <div class="tap-btn-large" data-action="1">${icon('rotateCcw',18,'#f4845f')} Play Again</div>
    <div style="display:flex;gap:8px">
      <div class="tap-btn" data-action="2" style="flex:1">Change Mode</div>
      <div class="tap-btn" data-action="3" style="flex:1">Change Level</div>
    </div>
    <div class="tap-btn" data-action="0" style="width:100%;color:#484f58">Menu</div>
  </div>`;
  return { text, cards };
}

function screenProgress() {
  const profile = getActiveProfile();
  const av = AVATARS.find(a => a.id === profile.avatar) || AVATARS[0];
  let lines = [
    '',
    `  ${av.face}  ${tc(esc(profile.name) + '\'s Progress', 'accent')}`,
    '',
    hr(),
    '',
  ];

  let totalMastered = 0;
  let totalWords = 0;

  LEVELS.forEach((lvl, i) => {
    const words = WORDS[lvl.key];
    totalWords += words.length;
    const mastered = words.filter(w => (profile.mastery[w]||{}).stars >= 5).length;
    totalMastered += mastered;
    const practiced = words.filter(w => (profile.mastery[w]||{}).seen > 0).length;
    const pct = Math.round((mastered / words.length) * 100);
    const current = profile.level === i ? tc(' ‚óÄ', 'accent') : '';

    lines.push(`  ${tc(lvl.icon + ' ' + lvl.name, 'blue')}${current}  ${tdim('(' + words.length + ' words)')}`);
    lines.push(`  ${progressBar(mastered, words.length, 25)} ${tc(pct + '%', pct === 100 ? 'green' : 'dim')}`);
    lines.push(`  ${tc(mastered + ' mastered', 'green')} ${tdim('|')} ${tc(practiced + ' practiced', 'dim')}`);
    lines.push('');
  });

  lines.push(hr());
  lines.push('');
  lines.push(`  Total: ${tc(totalMastered + '/' + totalWords + ' words mastered', 'green')}`);
  lines.push(`  Sessions: ${tc(profile.stats.sessionsPlayed, 'blue')}  Score: ${tc(profile.stats.totalScore, 'yellow')}  Streak: ${tc(profile.stats.bestStreak, 'accent')}`);
  lines.push('');

  const text = lines.join('\n');
  const cards = `<div style="padding:8px 0"><div class="tap-btn" data-action="0" style="width:100%;color:#484f58;gap:4px">${icon('chevronLeft',14,'#484f58')} Back</div></div>`;
  return { text, cards };
}

function screenHowToPlay() {
  let lines = [
    '',
    tb('  How to Play'),
    '',
    hr(),
    '',
    `  ${tc('‚ú¶ Flash', 'accent')}`,
    `  A word flashes on screen. After it`,
    `  disappears, tap the right word!`,
    '',
    `  ${tc('‚óß Fill', 'accent')}`,
    `  Some letters are missing. Tap the`,
    `  right letters to complete the word.`,
    '',
    `  ${tc('‚óà Scramble', 'accent')}`,
    `  Letters are jumbled up. Tap them`,
    `  in the right order!`,
    '',
    `  ${tc('‚ñ∂ Rush', 'accent')}`,
    `  60 seconds on the clock! Tap the`,
    `  matching word as fast as you can.`,
    `  Build streaks for bonuses!`,
    '',
    `  ${tc('‚ñ§ Story', 'accent')}`,
    `  Read a sentence with a blank.`,
    `  Tap the missing word.`,
    '',
    hr(),
    '',
    `  ${tc('Scoring:', 'yellow')}`,
    `  First try: ${tc('+10', 'green')}  Second try: ${tc('+5', 'blue')}`,
    `  Streak bonus: ${tc('+1 per word', 'accent')} in streak`,
    '',
    `  ${tc('Mastery:', 'yellow')}`,
    `  Get a word right 3 times in a row`,
    `  across sessions to earn ${tc('‚òÖ', 'yellow')} stars.`,
    `  5 stars = fully mastered!`,
    '',
  ];
  const text = lines.join('\n');
  const cards = `<div style="padding:8px 0"><div class="tap-btn" data-action="0" style="width:100%;color:#484f58;gap:4px">${icon('chevronLeft',14,'#484f58')} Back</div></div>`;
  return { text, cards };
}

function screenDiscovery() {
  const total = S.discoveryWords.length;
  const idx = S.discoveryIdx;
  const isTap = S.inputMode === 'tap';

  if (idx >= total) {
    // Show results
    const scores = [0,0,0,0,0]; // per level
    S.discoveryResults.forEach(r => { if (r.correct) scores[r.level]++; });
    // Find highest level where they got 2+ correct
    let bestLevel = 0;
    for (let i = 4; i >= 0; i--) {
      if (scores[i] >= 2) { bestLevel = i; break; }
    }

    const profile = getActiveProfile();
    profile.level = bestLevel;
    saveActiveProfile(profile);

    let lines = [
      '',
      centerBlock(owlArt('celebrate')),
      '',
      center(tc(tb('Discovery Complete!'), 'accent')),
      '',
    ];
    LEVELS.forEach((lvl, i) => {
      const s = scores[i];
      const bar = tc('‚óè'.repeat(s), 'green') + tdim('‚óã'.repeat(3 - s));
      const chosen = i === bestLevel ? tc(' ‚óÄ Your level!', 'accent') : '';
      lines.push(`  ${lvl.icon} ${lvl.name.padEnd(12)} ${bar}${chosen}`);
    });
    lines.push('');
    lines.push(center(`You are a ${tc(tb(LEVELS[bestLevel].icon + ' ' + LEVELS[bestLevel].name), 'blue')}!`));
    lines.push('');

    const text = lines.join('\n');
    const cards = `<div style="padding:8px 0"><div class="tap-btn-large" data-action="">Continue</div></div>`;
    return { text, cards };
  }

  const entry = S.discoveryWords[idx];
  const word = entry.word;
  const dots = S.discoveryWords.map((_, i) => {
    if (i < idx) return S.discoveryResults[i]?.correct ? tc('‚óè', 'green') : tc('‚óè', 'red');
    if (i === idx) return tc('‚óâ', 'accent');
    return tdim('‚óã');
  }).join(' ');

  let lines = [
    '',
    `  ${tc('‚óá Skill Discovery', 'blue')} ${tdim('‚îÇ')} ${idx + 1}/${total}`,
    '',
    `  ${dots}`,
    '',
    hr(),
    '',
  ];

  let cards = '';

  if (S.discoveryPhase === 'show') {
    lines.push(center(tdim('Look at this word:')));
    lines.push('');
    lines.push(center(tc(tb(word.toUpperCase()), 'fg')));
    lines.push('');
    lines.push(center(tdim('Remember it...')));
  } else {
    lines.push(center(tc('What was the word?', 'blue')));
    lines.push('');
    if (isTap) {
      cards = renderWordCards(S.discoveryChoices || [], word);
    }
  }
  lines.push('');
  return { text: lines.join('\n'), cards };
}

function screenDeleteConfirm() {
  const store = loadStore();
  const profile = store.profiles[S.deleteProfileIdx];
  if (!profile) return { text: '', cards: '' };
  const text = [
    '',
    center(tc(tb('Delete Profile?'), 'red')),
    '',
    center(`Are you sure you want to delete`),
    center(`${tc(esc(profile.name), 'accent')}'s profile?`),
    center(tdim('This cannot be undone.')),
    '',
  ].join('\n');
  const cards = `<div style="display:flex;gap:8px;padding:8px 0">
    <div class="tap-btn" data-action="yes" style="flex:1;color:#f85149;border-color:#f85149">Delete</div>
    <div class="tap-btn" data-action="no" style="flex:1">Keep</div>
  </div>`;
  return { text, cards };
}

// ‚îÄ‚îÄ‚îÄ LETTER TAP HANDLING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function handleLetterTap(letter, idx) {
  if (S.screen !== 'game') return;
  const word = S.words[S.wordIdx];

  if (S.mode === 2) {
    // Scramble: tap letters in order
    if (S.availableLetters[idx].used) return;
    S.selectedLetters.push({ letter, idx });
    S.availableLetters[idx].used = true;
    render();
    // Check if complete
    if (S.selectedLetters.length === word.length) {
      const answer = S.selectedLetters.map(x => x.letter).join('');
      setTimeout(() => checkAnswer(answer), 300);
    }
  } else if (S.mode === 1) {
    // Fill: tap letter to fill next empty slot
    const hint = S.hint;
    const slots = hint.split('');
    // Find next unfilled slot
    let filled = [...(S._filledLetters || [])];
    const blanks = [];
    for (let i = 0; i < slots.length; i++) {
      if (slots[i] === '_') blanks.push(i);
    }
    const nextBlank = blanks[filled.length];
    if (nextBlank === undefined) return;
    filled.push({ letter, idx, pos: nextBlank });
    S._filledLetters = filled;
    S.availableLetters[idx].used = true;
    render();
    // Check if all blanks filled
    if (filled.length === blanks.length) {
      const result = [...slots];
      filled.forEach(f => { result[f.pos] = f.letter; });
      const answer = result.join('');
      setTimeout(() => checkAnswer(answer), 300);
    }
  }
}

function handleLetterUndo() {
  if (S.screen !== 'game') return;
  if (S.mode === 2 && S.selectedLetters.length > 0) {
    const last = S.selectedLetters.pop();
    S.availableLetters[last.idx].used = false;
    render();
  } else if (S.mode === 1 && S._filledLetters && S._filledLetters.length > 0) {
    const last = S._filledLetters.pop();
    S.availableLetters[last.idx].used = false;
    render();
  }
}

// ‚îÄ‚îÄ‚îÄ GAME ENGINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function startRound() {
  sndGameStart();
  const levelKey = LEVELS[S.level].key;
  S.words = pickWords(levelKey, S.mode === 3 ? 40 : 10);
  S.wordIdx = 0;
  S.score = 0;
  S.streak = 0;
  S.bestStreak = 0;
  S.correct = 0;
  S.results = [];
  S.attempts = 0;
  S.screen = 'game';

  const profile = getActiveProfile();
  profile.stats.sessionsPlayed++;
  saveActiveProfile(profile);

  if (S.mode === 3) { // Rush
    S.rushTime = 60;
    S.rushActive = true;
    prepareWord();
    startRushTimer();
  } else {
    prepareWord();
  }
}

function prepareWord() {
  const word = S.words[S.wordIdx];
  const levelKey = LEVELS[S.level].key;
  S.attempts = 0;
  S.tappedCard = null;
  S._filledLetters = [];
  S._storySentence = null;
  S._storyWord = null;

  // Prepare tap-mode data
  if (S.inputMode === 'tap') {
    if (S.mode === 0 || S.mode === 3 || S.mode === 4) {
      // Word card modes: generate 3 distractors
      const distractors = generateDistractors(word, 3, levelKey);
      S.choices = shuffle([word, ...distractors]);
    } else if (S.mode === 1) {
      // Fill: generate letter tiles for missing + decoys
      S.hint = makeMissing(word);
      const missing = [];
      for (let i = 0; i < word.length; i++) {
        if (S.hint[i] === '_') missing.push(word[i]);
      }
      // Add 2-3 decoy letters
      const decoyPool = 'abcdefghijklmnopqrstuvwxyz'.split('').filter(c => !missing.includes(c));
      const decoys = shuffle(decoyPool).slice(0, Math.min(3, Math.max(2, missing.length)));
      S.availableLetters = shuffle([...missing, ...decoys]).map((l, i) => ({ letter: l, idx: i, used: false }));
      S._filledLetters = [];
    } else if (S.mode === 2) {
      // Scramble: scrambled letter tiles
      const scrambled = makeScramble(word);
      S.hint = scrambled;
      S.availableLetters = scrambled.split('').map((l, i) => ({ letter: l, idx: i, used: false }));
      S.selectedLetters = [];
    }
  } else {
    // Type mode: same as before
    if (S.mode === 1) S.hint = makeMissing(word);
    else if (S.mode === 2) S.hint = makeScramble(word);
  }

  if (S.mode === 0) { // Flash
    S.phase = 'show';
    S.inputEnabled = false;
    render();
    const dur = Math.max(3000, Math.min(6000, word.length * 600));
    S.timer = setTimeout(() => {
      S.phase = 'type';
      S.inputEnabled = true;
      render();
      if (S.inputMode === 'type') $('input').focus();
    }, dur);
  } else if (S.mode === 3) { // Rush
    S.phase = 'type';
    S.inputEnabled = true;
    render();
  } else {
    S.phase = 'type';
    S.inputEnabled = true;
    render();
  }
}

function startRushTimer() {
  if (S.rushTimer) clearInterval(S.rushTimer);
  S.rushTimer = setInterval(() => {
    S.rushTime--;
    if (S.rushTime <= 10) sndTick();
    if (S.rushTime <= 0) {
      clearInterval(S.rushTimer);
      S.rushTimer = null;
      S.rushActive = false;
      S.inputEnabled = false;
      sndLevelUp();
      // Save stats
      const profile = getActiveProfile();
      profile.stats.totalScore += S.score;
      if (S.bestStreak > profile.stats.bestStreak) profile.stats.bestStreak = S.bestStreak;
      saveActiveProfile(profile);
    }
    render();
  }, 1000);
}

function checkAnswer(answer) {
  const word = S.words[S.wordIdx];
  const correct = answer.toLowerCase().trim() === word.toLowerCase();
  const isTap = S.inputMode === 'tap';

  // Set tapped card for visual feedback (word-card modes in tap mode)
  if (isTap && (S.mode === 0 || S.mode === 3 || S.mode === 4)) {
    S.tappedCard = answer.toLowerCase().trim();
  }

  if (correct) {
    sndCorrect();
    const points = S.attempts === 0 ? 10 : 5;
    S.streak++;
    S.score += points + Math.min(S.streak, 5);
    if (S.streak > S.bestStreak) S.bestStreak = S.streak;
    S.correct++;
    S.results.push({ word, correct: true, attempts: S.attempts + 1 });

    const profile = getActiveProfile();
    updateMastery(profile, word, true);

    if (S.mode === 3 && !isTap) {
      S.wordIdx++;
      if (S.wordIdx >= S.words.length) {
        S.words = [...S.words, ...pickWords(LEVELS[S.level].key, 20)];
      }
      prepareWord();
      return;
    }

    // Flash green briefly, then next word
    render();
    setTimeout(() => {
      S.tappedCard = null;
      if (S.mode === 3) {
        S.wordIdx++;
        if (S.wordIdx >= S.words.length) {
          S.words = [...S.words, ...pickWords(LEVELS[S.level].key, 20)];
        }
        prepareWord();
      } else {
        nextWord();
      }
    }, isTap ? 400 : 150);
  } else {
    sndWrong();
    S.attempts++;
    S.streak = 0;

    if (S.mode === 3) {
      if (isTap) {
        render();
        setTimeout(() => { S.tappedCard = null; render(); }, 400);
      } else {
        render();
      }
      return;
    }

    if (S.attempts >= 2) {
      S.results.push({ word, correct: false, attempts: S.attempts });
      const profile = getActiveProfile();
      updateMastery(profile, word, false);
      render();
      setTimeout(() => { S.tappedCard = null; nextWord(); }, isTap ? 600 : 300);
    } else {
      if (isTap && (S.mode === 1 || S.mode === 2)) {
        S.selectedLetters = [];
        S._filledLetters = [];
        S.availableLetters.forEach(l => l.used = false);
      }
      render();
      if (isTap) setTimeout(() => { S.tappedCard = null; render(); }, 500);
    }
  }
}

function nextWord() {
  S.wordIdx++;
  if (S.wordIdx >= S.words.length) {
    // Round done
    const profile = getActiveProfile();
    profile.stats.totalScore += S.score;
    if (S.bestStreak > profile.stats.bestStreak) profile.stats.bestStreak = S.bestStreak;
    // Count newly mastered words
    const allWords = Object.values(WORDS).flat();
    profile.stats.wordsLearned = allWords.filter(w => (profile.mastery[w]||{}).stars >= 5).length;
    saveActiveProfile(profile);
    if (S.correct === S.words.length) sndLevelUp(); else sndTransition();
    S.screen = 'results';
    render();
  } else {
    S.screen = 'game';
    prepareWord();
  }
}

// Discovery
function startDiscovery() {
  // Pick 3 words from each level
  S.discoveryWords = [];
  Object.keys(WORDS).forEach((key, lvlIdx) => {
    const picked = shuffle(WORDS[key]).slice(0, 3);
    picked.forEach(w => S.discoveryWords.push({ word: w, level: lvlIdx }));
  });
  S.discoveryWords = shuffle(S.discoveryWords);
  S.discoveryResults = [];
  S.discoveryIdx = 0;
  S.discoveryPhase = 'show';
  S.screen = 'discovery';
  showDiscoveryWord();
}

function showDiscoveryWord() {
  if (S.discoveryIdx >= S.discoveryWords.length) {
    render();
    return;
  }
  S.discoveryPhase = 'show';
  S.inputEnabled = false;
  S.tappedCard = null;
  render();
  const entry = S.discoveryWords[S.discoveryIdx];
  const word = entry.word;
  const levelKey = Object.keys(WORDS)[entry.level];

  // Prepare choices for tap mode
  if (S.inputMode === 'tap') {
    const distractors = generateDistractors(word, 3, levelKey);
    S.discoveryChoices = shuffle([word, ...distractors]);
  }

  const dur = Math.max(2500, Math.min(5000, word.length * 500));
  S.timer = setTimeout(() => {
    S.discoveryPhase = 'type';
    S.inputEnabled = true;
    render();
    if (S.inputMode === 'type') $('input').focus();
  }, dur);
}

function checkDiscoveryAnswer(answer) {
  const entry = S.discoveryWords[S.discoveryIdx];
  const correct = answer.toLowerCase().trim() === entry.word.toLowerCase();
  const isTap = S.inputMode === 'tap';

  if (isTap) {
    S.tappedCard = answer.toLowerCase().trim();
    render(); // show green/red card
  }

  if (correct) sndCorrect(); else sndWrong();

  const proceed = () => {
    S.tappedCard = null;
    S.discoveryResults.push({ word: entry.word, level: entry.level, correct });
    S.discoveryIdx++;
    if (S.discoveryIdx >= S.discoveryWords.length) {
      sndLevelUp();
      render();
    } else {
      showDiscoveryWord();
    }
  };

  if (isTap) {
    setTimeout(proceed, 500);
  } else {
    proceed();
  }
}

// ‚îÄ‚îÄ‚îÄ RENDER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Helper: are we in a game answer screen where type/tap split matters?
function isGameAnswerScreen() {
  if (S.screen === 'game') return true;
  if (S.screen === 'discovery' && S.discoveryIdx < S.discoveryWords.length) return true;
  return false;
}

// Should the input bar be shown?
function shouldShowInputBar() {
  // Always show for profile name entry
  if (S.screen === 'newProfile' && !S.newName) return true;
  // In type mode during game answer screens, show input bar
  if (S.inputMode === 'type' && isGameAnswerScreen()) return true;
  return false;
}

function render() {
  updateW();
  const scr = $('screen');
  const input = $('input');
  const tapArea = $('tap-area');
  const inputBar = $('input-bar');
  let result = '';
  let cards = '';
  let placeholder = 'Type here...';

  switch (S.screen) {
    case 'welcome':
      result = screenWelcome();
      placeholder = 'Press ENTER...';
      break;
    case 'profiles':
      result = screenProfiles();
      placeholder = 'Choose profile...';
      break;
    case 'newProfile':
      result = screenNewProfile();
      placeholder = S.newName ? 'Pick avatar (1-5) or type "go"...' : 'Your name...';
      break;
    case 'menu':
      result = screenMenu();
      placeholder = 'Choose option...';
      break;
    case 'levelSelect':
      result = screenLevelSelect();
      placeholder = 'Choose level (1-5)...';
      break;
    case 'modeSelect':
      result = screenModeSelect();
      placeholder = 'Choose mode (1-5)...';
      break;
    case 'game':
      result = screenGame();
      if (S.mode === 0 && S.phase === 'show') {
        placeholder = 'Watch the word...';
      } else if (S.mode === 3 && !S.rushActive) {
        placeholder = 'Choose option...';
      } else {
        placeholder = 'Type your answer...';
      }
      break;
    case 'results':
      result = screenResults();
      placeholder = 'Choose option...';
      break;
    case 'progress':
      result = screenProgress();
      placeholder = 'Press 0 to go back...';
      break;
    case 'howToPlay':
      result = screenHowToPlay();
      placeholder = 'Press 0 to go back...';
      break;
    case 'discovery':
      result = screenDiscovery();
      if (S.discoveryIdx >= S.discoveryWords.length) {
        placeholder = 'Press ENTER...';
      } else {
        placeholder = S.discoveryPhase === 'show' ? 'Watch...' : 'Type the word...';
      }
      break;
    case 'deleteConfirm':
      result = screenDeleteConfirm();
      placeholder = 'Type yes or no...';
      break;
  }

  // Handle {text, cards} return or plain string
  let content = '';
  if (typeof result === 'object' && result !== null) {
    content = result.text || '';
    cards = result.cards || '';
  } else {
    content = result;
  }

  // In type mode during game screens, suppress cards and show input bar
  if (S.inputMode === 'type' && isGameAnswerScreen()) {
    cards = '';
  }

  scr.innerHTML = content;
  scr.className = 'px-4 sm:px-6 pt-4 pb-2 text-t-fg text-[16px] sm:text-[18px] leading-[1.6] whitespace-pre-wrap fade-in flex-1 min-h-0 overflow-y-auto';

  // Tap area visibility
  if (cards) {
    tapArea.innerHTML = cards;
    tapArea.classList.remove('hidden');
  } else {
    tapArea.innerHTML = '';
    tapArea.classList.add('hidden');
  }

  // Input bar visibility
  const showInput = shouldShowInputBar();
  inputBar.style.display = showInput ? '' : 'none';
  if (showInput) {
    input.placeholder = placeholder;
    input.disabled = !S.inputEnabled;
    if (S.inputEnabled) input.focus();
  }

  // Update title bar, back button, mode button
  const profile = getActiveProfile();
  const titleBar = $('title-bar');
  const backBtn = $('back-btn');
  if (profile) {
    titleBar.textContent = `owlsh ‚Äî ${profile.name}`;
  } else {
    titleBar.textContent = 'owlsh v1.0';
  }
  const hasBack = S.screen !== 'welcome';
  if (backBtn) {
    backBtn.className = hasBack ? 'text-xs visible' : '';
    backBtn.innerHTML = hasBack ? `${icon('chevronLeft',14,'#8b949e')} <span style="color:#8b949e">back</span>` : '';
  }
  // Update settings panel
  const sMuteRow = $('s-mute-row');
  if (sMuteRow) sMuteRow.innerHTML = muted ? `${icon('volumeX',14,'#484f58')} <span style="margin-left:6px">Sound off</span>` : `${icon('volume2',14)} <span style="margin-left:6px">Sound on</span>`;
  const sModeRow = $('s-mode-row');
  if (sModeRow) sModeRow.innerHTML = S.inputMode === 'tap' ? `${icon('hand',14)} <span style="margin-left:6px">Tap mode</span>` : `${icon('keyboard',14)} <span style="margin-left:6px">Type mode</span>`;
  const sLevels = $('s-levels');
  if (sLevels) {
    const profile = getActiveProfile();
    const inGame = isInActiveGame();
    let html = '';
    if (profile) {
      LEVELS.forEach((lvl, i) => {
        const active = profile.level === i ? 'color:#f4845f;' : '';
        const cls = inGame ? ' disabled' : '';
        html += `<div class="settings-row${cls}" onclick="setLevel(${i})"><span>${lvl.icon} ${lvl.name}</span><span class="settings-val" style="${active}">${profile.level === i ? '‚óÄ' : ''}</span></div>`;
      });
    } else {
      html = '<div class="settings-row disabled"><span style="color:#484f58">No profile</span></div>';
    }
    sLevels.innerHTML = html;
  }

  // Scale logo to fit on small screens
  const logoEl = scr.querySelector('.logo-wrap');
  if (logoEl) {
    const contentPx = scr.clientWidth - parseFloat(getComputedStyle(scr).paddingLeft) - parseFloat(getComputedStyle(scr).paddingRight);
    const logoChars = 43; // LOGO width in characters
    const ruler = document.createElement('span');
    ruler.style.cssText = 'position:absolute;visibility:hidden;white-space:pre';
    ruler.textContent = '0'.repeat(logoChars);
    scr.appendChild(ruler);
    const logoPx = ruler.getBoundingClientRect().width;
    scr.removeChild(ruler);
    if (logoPx > contentPx) {
      const scale = contentPx / logoPx;
      logoEl.style.transform = `scale(${scale.toFixed(3)})`;
      logoEl.style.marginBottom = `-${(1 - scale) * logoEl.scrollHeight * 0.8}px`;
    } else {
      logoEl.style.transform = '';
      logoEl.style.marginBottom = '';
    }
  }

  saveSession();
}

// ‚îÄ‚îÄ‚îÄ INPUT ROUTER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function handleInput(value) {
  const v = value.trim();
  const vl = v.toLowerCase();

  switch (S.screen) {
    case 'welcome':
      initAudio();
      if (!S.introPlayed) { sndIntro(); S.introPlayed = true; }
      S.screen = 'profiles';
      break;

    case 'profiles': {
      const store = loadStore();
      if (v === '+' || (store.profiles.length === 0 && v === '1')) {
        S.newName = '';
        S.newAvatar = 0;
        S.screen = 'newProfile';
      } else if (v.startsWith('delete-')) {
        const delIdx = parseInt(v.split('-')[1]);
        if (delIdx >= 0 && delIdx < store.profiles.length) {
          S.deleteProfileIdx = delIdx;
          S.screen = 'deleteConfirm';
        }
      } else {
        const idx = parseInt(v) - 1;
        if (idx >= 0 && idx < store.profiles.length) {
          setActiveProfileIndex(idx);
          sndTransition();
          S.screen = 'menu';
        }
      }
      break;
    }

    case 'newProfile':
      if (!S.newName) {
        if (v) {
          S.newName = v.slice(0, 20);
        }
      } else if (vl === 'go' || vl === 'done' || vl === 'create') {
        const av = AVATARS[S.newAvatar];
        createProfile(S.newName, av.id);
        sndTransition();
        S.screen = 'menu';
      } else {
        const n = parseInt(v) - 1;
        if (n >= 0 && n < AVATARS.length) S.newAvatar = n;
      }
      break;

    case 'menu':
      if (v === '1') {
        const profile = getActiveProfile();
        if (profile.level === null) {
          // Need discovery first
          startDiscovery();
          return;
        }
        S.level = profile.level;
        S.screen = 'levelSelect';
      } else if (v === '2') {
        startDiscovery();
        return;
      } else if (v === '3') {
        S.screen = 'progress';
      } else if (v === '4') {
        S.screen = 'howToPlay';
      }
      break;

    case 'deleteConfirm':
      if (vl === 'yes') {
        const store = loadStore();
        const delIdx = S.deleteProfileIdx;
        store.profiles.splice(delIdx, 1);
        // Fix active profile index after removal
        if (store.activeProfile === delIdx) {
          store.activeProfile = store.profiles.length > 0 ? 0 : null;
        } else if (store.activeProfile > delIdx) {
          store.activeProfile--;
        }
        saveStore(store);
        S.deleteProfileIdx = null;
        S.screen = 'profiles';
      } else {
        S.deleteProfileIdx = null;
        S.screen = 'profiles';
      }
      break;

    case 'levelSelect':
      if (v === '0') { S.screen = 'menu'; break; }
      const lvl = parseInt(v) - 1;
      if (lvl >= 0 && lvl < LEVELS.length) {
        S.level = lvl;
        S.screen = 'modeSelect';
      }
      break;

    case 'modeSelect':
      if (v === '0') { S.screen = 'levelSelect'; break; }
      const mode = parseInt(v) - 1;
      if (mode >= 0 && mode < MODES.length) {
        S.mode = mode;
        startRound();
        return;
      }
      break;

    case 'game':
      if (S.mode === 0 && S.phase === 'show') return;
      if (S.mode === 3 && !S.rushActive) {
        // Rush ended ‚Äî menu options
        if (v === '1') { startRound(); return; }
        if (v === '2') { S.screen = 'modeSelect'; break; }
        if (v === '0') { S.screen = 'menu'; break; }
        return;
      }
      if (v) {
        checkAnswer(v);
        return;
      }
      break;

    case 'results':
      if (v === '1') { startRound(); return; }
      if (v === '2') { S.screen = 'modeSelect'; break; }
      if (v === '3') { S.screen = 'levelSelect'; break; }
      if (v === '0') { S.screen = 'menu'; break; }
      break;

    case 'progress':
    case 'howToPlay':
      if (v === '0' || v === '') S.screen = 'menu';
      break;

    case 'discovery':
      if (S.discoveryIdx >= S.discoveryWords.length) {
        // Results screen ‚Äî press enter to continue
        sndTransition();
        S.screen = 'menu';
        break;
      }
      if (S.discoveryPhase === 'show') return;
      if (v) {
        checkDiscoveryAnswer(v);
        return;
      }
      break;
  }

  render();
}

// ‚îÄ‚îÄ‚îÄ TAP HANDLING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
{
  const tapArea = $('tap-area');
  tapArea.addEventListener('click', (e) => {
    const btn = e.target.closest('[data-action]');
    if (!btn) return;
    e.preventDefault();
    e.stopPropagation();
    const action = btn.dataset.action;
    if (action === 'letter-tap') {
      handleLetterTap(btn.dataset.letter, parseInt(btn.dataset.idx));
    } else if (action === 'undo-letter') {
      handleLetterUndo();
    } else {
      handleInput(action);
    }
  });
  // Touch feedback
  tapArea.addEventListener('touchstart', (e) => {
    const btn = e.target.closest('[data-action]');
    if (btn) btn.classList.add('pressing');
  }, { passive: true });
  tapArea.addEventListener('touchend', () => {
    tapArea.querySelectorAll('.pressing').forEach(el => el.classList.remove('pressing'));
  }, { passive: true });
  tapArea.addEventListener('touchcancel', () => {
    tapArea.querySelectorAll('.pressing').forEach(el => el.classList.remove('pressing'));
  }, { passive: true });
}

// ‚îÄ‚îÄ‚îÄ INIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const input = $('input');

function goBack() {
  input.value = '';
  if (S.timer) { clearTimeout(S.timer); S.timer = null; }
  if (S.rushTimer) { clearInterval(S.rushTimer); S.rushTimer = null; }
  S.inputEnabled = true;
  if (S.screen === 'game' || S.screen === 'results') {
    S.screen = 'modeSelect';
  } else if (S.screen === 'discovery') {
    S.screen = 'menu';
  } else if (S.screen === 'modeSelect') {
    S.screen = 'levelSelect';
  } else if (S.screen === 'levelSelect') {
    S.screen = 'menu';
  } else if (S.screen === 'deleteConfirm') {
    S.deleteProfileIdx = null;
    S.screen = 'profiles';
  } else if (S.screen === 'progress' || S.screen === 'howToPlay') {
    S.screen = 'menu';
  } else if (S.screen === 'newProfile') {
    S.screen = 'profiles';
  } else if (S.screen === 'menu') {
    const store = loadStore();
    store.activeProfile = null;
    saveStore(store);
    S.screen = 'profiles';
  } else if (S.screen === 'profiles') {
    const store = loadStore();
    store.activeProfile = null;
    saveStore(store);
    S.screen = 'welcome';
    clearSession();
  }
  render();
}

input.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    e.preventDefault();
    goBack();
    return;
  }
  if (e.key === 'Enter') {
    e.preventDefault();
    const val = input.value;
    input.value = '';
    handleInput(val);
  }
});

// Close settings on outside click + keep focus on input
document.addEventListener('click', (e) => {
  if (!e.target.closest('#settings-wrap')) closeSettings();
  if ($('input-bar').style.display !== 'none' && !input.disabled && !e.target.closest('#tap-area') && !e.target.closest('#back-btn') && !e.target.closest('#settings-wrap')) {
    input.focus();
  }
});

// Scroll input into view when mobile keyboard opens
if (window.visualViewport) {
  window.visualViewport.addEventListener('resize', () => {
    if ($('input-bar').style.display !== 'none') {
      $('input-bar').scrollIntoView({ block: 'end', behavior: 'smooth' });
    }
  });
}

// Cleanup timers on page unload
window.addEventListener('beforeunload', () => {
  if (S.timer) clearTimeout(S.timer);
  if (S.rushTimer) clearInterval(S.rushTimer);
});

// ‚îÄ‚îÄ‚îÄ SESSION PERSISTENCE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SESSION_KEY = 'owlsh_session';
const SESSION_FIELDS = [
  'screen','level','mode','words','wordIdx','score','streak','bestStreak',
  'correct','results','phase','attempts','hint','choices',
  'selectedLetters','availableLetters','_filledLetters',
  '_storySentence','_storyWord',
  'rushTime','rushActive',
  'discoveryWords','discoveryResults','discoveryIdx','discoveryPhase','discoveryChoices',
  'newName','newAvatar',
];

function saveSession() {
  const snap = {};
  SESSION_FIELDS.forEach(k => { snap[k] = S[k]; });
  try { localStorage.setItem(SESSION_KEY, JSON.stringify(snap)); } catch {}
}

function restoreSession() {
  try {
    const raw = localStorage.getItem(SESSION_KEY);
    if (!raw) return false;
    const snap = JSON.parse(raw);
    if (!snap || !snap.screen) return false;

    // Only restore if the active profile still exists
    const store = loadStore();
    if (store.activeProfile === null || !store.profiles[store.activeProfile]) return false;

    SESSION_FIELDS.forEach(k => { if (snap[k] !== undefined) S[k] = snap[k]; });

    // Timers can't persist ‚Äî fix up phase states
    if (S.screen === 'game') {
      if (S.mode === 0 && S.phase === 'show') {
        // Flash was showing word ‚Äî skip to answer phase
        S.phase = 'type';
        S.inputEnabled = true;
      }
      if (S.mode === 3 && S.rushActive) {
        // Rush ‚Äî restart countdown from saved time
        S.inputEnabled = true;
        startRushTimer();
      }
    } else if (S.screen === 'discovery') {
      if (S.discoveryPhase === 'show' && S.discoveryIdx < S.discoveryWords.length) {
        S.discoveryPhase = 'type';
        S.inputEnabled = true;
      }
    }
    return true;
  } catch { return false; }
}

function clearSession() {
  localStorage.removeItem(SESSION_KEY);
}

function initScreen() {
  if (restoreSession()) return;
  const store = loadStore();
  if (store.activeProfile !== null && store.profiles[store.activeProfile]) {
    S.screen = 'menu';
  } else {
    S.screen = 'welcome';
  }
}

initScreen();
render();
window.addEventListener('resize', () => { updateW(); render(); });

// Dismiss splash screen
{
  const splashEl = $('splash');
  if (splashEl) {
    // Show for at least 1.2s so the art is visible, then fade out
    const minTime = 1200;
    const start = performance.now();
    function dismissSplash() {
      const elapsed = performance.now() - start;
      const remaining = Math.max(0, minTime - elapsed);
      setTimeout(() => {
        splashEl.classList.add('fade-out');
        setTimeout(() => splashEl.remove(), 400);
      }, remaining);
    }
    // Dismiss on tap/click or after min time
    splashEl.addEventListener('click', dismissSplash, { once: true });
    splashEl.addEventListener('touchstart', dismissSplash, { once: true });
    setTimeout(dismissSplash, minTime);
  }
}

// Play intro music on welcome screen load
// Try immediately (works for returning visitors); fallback to first interaction
if (S.screen === 'welcome') {
  initAudio();
  if (actx && actx.state === 'running') {
    sndIntro();
    S.introPlayed = true;
  } else {
    // Browser blocked autoplay ‚Äî play on first interaction
    function onFirstInteraction() {
      if (!S.introPlayed && S.screen === 'welcome') {
        initAudio();
        sndIntro();
        S.introPlayed = true;
      }
      document.removeEventListener('click', onFirstInteraction);
      document.removeEventListener('touchstart', onFirstInteraction);
    }
    document.addEventListener('click', onFirstInteraction);
    document.addEventListener('touchstart', onFirstInteraction);
  }
}

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(() => {});
}

</script>
</body>
</html>
